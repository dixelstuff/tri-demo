<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Trigram Demo</title>

  <style>
    :root{
      --bg:#a9cdf3;
      --bubble:#fff;
      --ink:#0b0b0b;

      --w1:#fff3b3;   /* yellow */
      --w2:#cfe8ff;   /* blue */
      --ol:#c9f3d6;   /* green overlap */
      --bad:#ffc9d2;  /* red/pink warning */
      --submit:#F4D2FD;

      --kb-h: 260px;
      --caret: rgba(0,0,0,.18);
    }

    *{ box-sizing:border-box; }
    html, body{
      height:100%;
      overflow:hidden;
      overscroll-behavior:none;
      background:var(--bg);
    }
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
      color:var(--ink);
      text-align:center;
      -webkit-text-size-adjust: 100%;
    }

    #clue, #clue *,
    #gridDock, #gridDock *,
    #gridWrap, #gridWrap *,
    #hintTrack, #hintTrack *,
    #btnRow, #btnRow *,
    #kbHost, #kbHost *{
      -webkit-user-select:none;
      user-select:none;
      -webkit-touch-callout:none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    .wrap{
      height:100dvh;
      max-height:100dvh;
      width:100%;
      max-width:980px;
      margin:0 auto;
      padding:12px 14px 14px;
      display:flex;
      flex-direction:column;
      align-items:stretch;
      justify-content:flex-start;
      overflow:hidden;
      position:relative;
    }

    /* NEW: reserve space when we pin the dock + keyboard */
    html.has-kb .wrap{
      padding-bottom: calc(var(--kb-h) + 170px + env(safe-area-inset-bottom));
    }

    .toprow{
      display:flex;
      justify-content:center;
      align-items:center;
      margin-top:2px;
      flex:0 0 auto;
    }
    .nav{
      display:flex;
      align-items:center;
      gap:10px;
      font-weight:900;
    }
    .nav a, .nav button{
      color:var(--ink);
      text-decoration:none;
      font-weight:900;
      padding:5px 10px;
      border-radius:999px;
      background:rgba(255,255,255,.32);
      border:2px solid rgba(0,0,0,.16);
      cursor:pointer;
      appearance:none;
      -webkit-appearance:none;
      font:inherit;
    }
    .nav a:active, .nav button:active{ transform:translateY(1px); }
    .count{ font-weight:900; opacity:.7; min-width:58px; text-align:center; }

    .clue{
      display:block;
      width:fit-content;
      max-width:min(940px,94vw);
      margin: clamp(18px, 3.6vh, 36px) auto 0;
      padding:14px 13px 15px 20px;
      background:var(--bubble);
      border-radius:18px;
      box-shadow:0 2px 6px rgba(0,0,0,.08);
      font-size:clamp(30px,5.4vw,38px);
      line-height:1.12;
      letter-spacing:.12px;
      font-weight:400;
      flex:0 0 auto;
    }
    .clue .len{
      opacity:.55;
      display:inline-block;
      font-size:0.92em;
      line-height:1;
      vertical-align:middle;
      position: relative;
      top: -0.1em;
      margin-left:8px;
    }

    .clueWord{
      display:inline-block;
      cursor:pointer;
      font-kerning: none;
      font-variant-ligatures: none;
      font-feature-settings: "kern" 0, "liga" 0, "clig" 0;
    }

    .u-w1, .u-w2, .u-red{
      text-decoration: underline;
      text-decoration-thickness: 6px;
      text-underline-offset: 9px;
      pointer-events: none;
    }
    .u-w1{ text-decoration-color: rgba(255,220,0,.9); }
    .u-w2{ text-decoration-color: rgba(70,160,255,.92); }
    .u-red{ text-decoration-color: rgba(235,80,92,.92); }

    .gridDock{
      display:block;
      width:fit-content;
      margin: clamp(38px, 6.0vh, 58px) auto 0;
      position:relative;
      flex:0 0 auto;
      border-radius:14px;
      box-shadow:0 3px 8px rgba(0,0,0,.08);
      z-index: 20;
      isolation: isolate;
    }
    html.has-kb .gridDock{
      margin: clamp(52px, 8.0vh, 86px) auto 0;
    }

    .gridDock.shake{ animation:shake .16s linear 0s 2; }
    @keyframes shake{
      0%{ transform:translateX(0); }
      25%{ transform:translateX(-6px); }
      50%{ transform:translateX(6px); }
      75%{ transform:translateX(-4px); }
      100%{ transform:translateX(0); }
    }

    .gridWrap{
      display:block;
      border:4px solid var(--ink);
      border-radius:14px;
      overflow:hidden;
      background:#fff;
    }

    .grid{
      --n: 7;
      --gap: 3px;
      --cell: 44px;
      display:grid;
      grid-template-columns:repeat(var(--n), 1fr);
      gap: var(--gap);
      background: var(--ink);
      width: min(calc(var(--n) * var(--cell) + (var(--n) - 1) * var(--gap)), 92vw);
    }
    .cell{
      aspect-ratio:1/1;
      display:flex;
      align-items:center;
      justify-content:center;
      background:#fff;
      position:relative;
    }

    .cell.active::after{
      content:"";
      position:absolute;
      height:3px;
      width:62%;
      left:50%;
      bottom:12%;
      transform:translateX(-50%);
      background:var(--caret);
      border-radius:999px;
      animation: caretBlink 1.1s steps(2,end) infinite;
      pointer-events:none;
      opacity:1;
    }
    @keyframes caretBlink{
      0%, 46%{ opacity:1; }
      47%, 100%{ opacity:0; }
    }

    .cell input{
      width:100%;
      height:100%;
      border:0; outline:none;
      background:transparent;
      text-align:center;
      font-size:clamp(23px,5.1vw,32px);
      font-weight:900;
      font-style:italic;
      padding:0; margin:0;
      color:var(--ink);
      text-transform:lowercase;
      caret-color: transparent;
      appearance:none;
      -webkit-appearance:none;
      border-radius:0;
      -webkit-tap-highlight-color: transparent;
    }

    .cell.bg-w1{ background:var(--w1); }
    .cell.bg-w2{ background:var(--w2); }
    .cell.bg-ol{ background:var(--ol); }
    .cell.bg-bad{ background:var(--bad) !important; }

    .cell.grabbable{ cursor:grab; }
    .cell.grabbable:active{ cursor:grabbing; }
    .cell.grabbable input{ pointer-events:none; cursor:grab; }

    html.has-kb .cell input{ pointer-events:none; }

    .msgSlot{
      position:relative;
      height: 98px;
      width:100%;
      max-width:760px;
      margin: clamp(6px, 1.3vh, 12px) auto 0;
      flex:0 0 auto;
      pointer-events:none;
    }
    .msg{
      position:absolute;
      left:50%;
      transform:translateX(-50%);
      top: 18px;
      margin:0;
      font-weight:900;
      opacity:0;
      transition:opacity .18s ease, transform .18s ease;
      font-style:italic;
      font-size:22px;
      pointer-events:none;
      width:max-content;
      max-width:min(92vw,760px);
      white-space: pre-line;
      line-height:1.15;
      text-align:center;
    }
    .msg.show{ opacity:.92; }
    .msg.warn{ opacity:.92; font-size:20px; }
    .msg.result{ top: 28px; }

    /* =========================
       NEW: Bottom Dock
       - contains hintTrack + buttons
       - fixed above keyboard in has-kb
       ========================= */
    #bottomDock{
      flex:0 0 auto;
      width:100%;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:12px;
      margin-top: clamp(14px, 3.4vh, 24px);
      position:relative;
      z-index: 30;
    }

    html.has-kb #bottomDock{
      position:fixed;
      left:0; right:0;
      bottom: calc(var(--kb-h) + env(safe-area-inset-bottom) + 12px);
      margin:0;
      padding: 8px 0 2px;
      z-index:9997;
    }

    .hintTrack{
      width:fit-content;
      max-width:min(920px,96vw);
      min-height:78px;
      display:flex;
      align-items:center;
      justify-content:center;
      transition:opacity .35s ease;
    }
    /* when dock is fixed, don't “lift” the hint row */
    html.has-kb .hintTrack{ transform:none !important; }

    .trackRow{
      display:flex;
      align-items:flex-start;
      justify-content:center;
      gap:18px;
      flex-wrap:nowrap;
      transition: opacity .35s ease;
    }
    .wrap.solved .trackRow{ opacity:0; }

    .trackBlock{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:6px;
      min-width:0;
    }

    .letters{
      display:inline-flex;
      background:transparent;
      overflow:visible;
      position:relative;
      flex:0 0 auto;
    }
    .letters.clickable{ cursor:pointer; }

    .letter{
      width:29px;
      height:29px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:900;
      font-style:italic;
      font-size:19px;
      text-transform:lowercase;
      position:relative;
      background:rgba(255,255,255,.35);
      transition:opacity .15s ease, background .15s ease, transform .08s ease;
      border:1px solid rgba(0,0,0,.22);
    }
    .letter + .letter{ margin-left:-1px; }
    .letter.sel-w1{ background:var(--w1); }
    .letter.sel-w2{ background:var(--w2); }

    .letter.extra{
      background:rgba(255,255,255,.95);
      cursor:pointer;
      font-style:italic;
    }
    .letter.extra:active{ transform:translateY(1px); }

    .extrasRow{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:center;
      flex-wrap:nowrap;
    }

    .btnRow{
      display:flex;
      justify-content:center;
      gap:12px;
      flex-wrap:wrap;
      padding-bottom: 2px;
      margin:0;               /* NOTE: dock gap handles spacing now */
      width:100%;
    }
    .btn{
      border:4px solid var(--ink);
      border-radius:999px;
      padding:9px 16px;
      min-width:104px;
      font-size:20px;
      font-weight:900;
      font-style:italic;
      color:var(--ink);
      background:rgba(255,255,255,.35);
      cursor:pointer;
      text-transform:lowercase;
      appearance:none;
      -webkit-appearance:none;
      box-shadow: 0 7px 0 rgba(0,0,0,.16);
    }
    .btn:active{
      transform:translateY(1px);
      box-shadow: 0 6px 0 rgba(0,0,0,.16);
    }
    .btn.hints{ background:#fff3bd; }
    .btn.check{ background:rgba(255,255,255,.25); opacity:.55; }
    .btn.check.ready{ opacity:1; background:var(--submit); }
    .btn:disabled{
      opacity:.35 !important;
      cursor:default;
      transform:none !important;
      box-shadow: 0 7px 0 rgba(0,0,0,.10);
    }

    /* fade buttons on solve (same behaviour you wanted) */
    .wrap.solved #btnRow{
      opacity:0;
      transform: translateY(6px);
      pointer-events:none;
      transition: opacity .35s ease, transform .35s ease;
    }

    .ghost{
      position:fixed;
      z-index:9999;
      pointer-events:none;
      transform: translate(-50%, -50%);
      filter: drop-shadow(0 14px 16px rgba(0,0,0,.22));
      opacity:.95;
    }

    .kbHost{
      position:fixed;
      left:0; right:0;
      bottom:0;
      z-index:9996;
      display:none;
      padding:10px 10px calc(22px + env(safe-area-inset-bottom));
      background:rgba(255,255,255,.90);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border-top:2px solid rgba(0,0,0,.14);
      touch-action: manipulation;
    }
    html.has-kb .kbHost{ display:block; }

    .kb{
      max-width:560px;
      margin:0 auto;
      display:flex;
      flex-direction:column;
      gap:8px;
      --keyW: clamp(28px, 8.6vw, 48px);
    }
    .kbRow{
      display:flex;
      justify-content:center;
      gap:4px;
    }
    .kbKey{
      width: var(--keyW);
      height: 48px;
      border:2px solid rgba(0,0,0,.16);
      border-radius:11px;
      background:rgba(255,255,255,.82);
      font-weight:700;
      text-transform:none;
      font-size: 18px;
      color: var(--ink);
      cursor:pointer;
    }
    .kbKey:active{ transform:translateY(1px); }
    .kbKey.wide{
      width: calc(var(--keyW) * 1.55);
      font-size: 12px;
      font-weight: 900;
      letter-spacing: .08em;
    }
    .kbKey.enter:not(.is-disabled){ background: rgba(0,0,0,.07); }
    .kbKey.is-disabled{
      opacity:.38;
      background: rgba(0,0,0,.04);
      border-color: rgba(0,0,0,.10);
      transform:none !important;
      cursor:default;
    }

    @media (max-width:520px){
      .nav a{ padding:4px 9px; }
      .clue{
        font-size:clamp(32px,6.6vw,38px);
        margin-top: clamp(16px, 3.4vh, 28px);
      }
      .grid{ --cell: 43px; width: min(calc(var(--n) * var(--cell) + (var(--n) - 1) * var(--gap)), 94vw); }
      .cell input{ font-size:clamp(24px,6.05vw,36px); }
      .letter{ width:28px; height:28px; font-size:19px; }
      .btn{ font-size:19px; padding:9px 15px; min-width:98px; }
      .kbKey{ height:46px; }
    }
  </style>
</head>

<body>
  <div class="wrap" id="wrap">
    <div class="toprow">
      <div class="nav">
        <a href="#" id="prevBtn" aria-label="Previous puzzle">‹</a>
        <span class="count" id="count"></span>
        <a href="#" id="nextBtn" aria-label="Next puzzle">›</a>
      </div>
    </div>

    <div class="clue" id="clue"></div>

    <div class="gridDock" id="gridDock">
      <div class="gridWrap" id="gridWrap" aria-label="Answer grid">
        <div class="grid" id="grid" style="--n:7"></div>
      </div>
    </div>

    <div class="msgSlot" id="msgSlot" aria-live="polite">
      <div class="msg" id="msg"></div>
    </div>

    <!-- NEW: bottom dock holds mini-hints + buttons together -->
    <div id="bottomDock">
      <div class="hintTrack" id="hintTrack" aria-label="Hint tracker">
        <div class="trackRow" id="trackRow">
          <div class="trackBlock" id="trackW1"></div>
          <div class="trackBlock" id="trackW2"></div>
          <div class="trackBlock" id="trackExtras"></div>
        </div>
      </div>

      <div class="btnRow" id="btnRow">
        <button class="btn hints" id="hintsBtn" type="button">hint 1</button>
        <button class="btn check" id="checkBtn" type="button">check</button>
      </div>
    </div>
  </div>

  <div class="kbHost" id="kbHost" aria-label="On-screen keyboard"></div>

<script>
/* =======================
   Puzzles
   ======================= */
const PUZZLES = [
  { clue:"Danger mishaps", word1:"danger", word2:"mishaps", answer:"anguish", tri1:"ang", tri2:"ish" },
  { clue:"Lavish phonons", word1:"lavish", word2:"phonons", answer:"visions", tri1:"vis", tri2:"ons" },
  { clue:"Horizon swifter", word1:"horizon", word2:"swifter", answer:"shorter", tri1:"hor", tri2:"ter" },
  { clue:"Muscle voter", word1:"muscle", word2:"voter", answer:"musters", tri1:"mus", tri2:"ter" },
  { clue:"Greater harken", word1:"greater", word2:"harken", answer:"charter", tri1:"ter", tri2:"har" },
  { clue:"Blast updraft", word1:"blast", word2:"updraft", answer:"drastic", tri1:"ast", tri2:"dra" },
];

const TR = 3;

const el = {
  wrap: document.getElementById('wrap'),
  clue: document.getElementById('clue'),
  gridDock: document.getElementById('gridDock'),
  gridWrap: document.getElementById('gridWrap'),
  grid: document.getElementById('grid'),
  msg: document.getElementById('msg'),
  hintTrack: document.getElementById('hintTrack'),
  trackW1: document.getElementById('trackW1'),
  trackW2: document.getElementById('trackW2'),
  trackExtras: document.getElementById('trackExtras'),
  hintsBtn: document.getElementById('hintsBtn'),
  checkBtn: document.getElementById('checkBtn'),
  btnRow: document.getElementById('btnRow'),
  prevBtn: document.getElementById('prevBtn'),
  nextBtn: document.getElementById('nextBtn'),
  count: document.getElementById('count'),
  kbHost: document.getElementById('kbHost'),
  bottomDock: document.getElementById('bottomDock'),
};

const OVERLAP_TEXT = "1-letter overlap allowed ✓";
const TWOTRI_TEXT  = "Two trigrams from same word";

const state = {
  i: 0,
  finished: false,
  gaveUp: false,

  hintCount: 0,
  hintsUsed: { w1:false, w2:false, extras:false },

  assist: true,

  placed: { w1:null, w2:null },
  singles: [],
  focusIdx: 0,

  sel1: 0,
  sel2: 0,

  drag: null,
  justDraggedAt: 0,

  msgTimer: null,
  msgTransient: false,
  lockMsg: false,

  wrongCheckCount: 0,
  cycleCount: 0,

  bank: [],

  badSet: new Set(),
  twoSet: new Set(),
  exclSet: new Set(),

  useCustomKB: false,
};

function clamp(n,min,max){ return Math.max(min, Math.min(max, n)); }
function norm(s){ return String(s||"").toLowerCase().replace(/[^a-z]/g,""); }
function isAlpha(ch){ return /^[a-z]$/i.test(ch); }
function uid(){ return Math.random().toString(16).slice(2) + Date.now().toString(16); }
function current(){ return PUZZLES[state.i]; }

function getN(){
  const a = norm(current().answer);
  return clamp(a.length || 7, 6, 8);
}
function startMax(){ return Math.max(0, getN() - TR); }

function clearMsgTimer(){
  if(state.msgTimer){ clearTimeout(state.msgTimer); state.msgTimer=null; }
  state.msgTransient = false;
}
function setMsg(text, kind){
  clearMsgTimer();
  el.msg.classList.remove('show','warn','result');
  el.msg.textContent = text || "";
  if(!text) return;
  void el.msg.offsetWidth;
  el.msg.classList.add('show');
  if(kind === 'warn') el.msg.classList.add('warn');
  if(kind === 'result') el.msg.classList.add('result');
}
function setTransientMsg(text, ms=1800, kind=null){
  setMsg(text, kind);
  state.msgTransient = true;
  state.msgTimer = setTimeout(()=>{
    el.msg.classList.remove('show','warn','result');
    el.msg.textContent = "";
    state.msgTimer = null;
    state.msgTransient = false;
  }, ms);
}

function trigramCells(start){ return [start, start+1, start+2]; }
function overlapCount(aStart, bStart){
  const a = new Set(trigramCells(aStart));
  let c=0;
  for(const i of trigramCells(bStart)) if(a.has(i)) c++;
  return c;
}
function overlapMatchIdx(aStart, bStart){
  const a = new Set(trigramCells(aStart));
  for(const i of trigramCells(bStart)) if(a.has(i)) return i;
  return null;
}
function overlapIsValid(aStart, aTri, bStart, bTri){
  const ol = overlapCount(aStart, bStart);
  if(ol === 0) return true;
  if(ol !== 1) return false;
  const common = overlapMatchIdx(aStart, bStart);
  const aCh = aTri[common - aStart];
  const bCh = bTri[common - bStart];
  return aCh === bCh;
}

function trigramAtIndex(idx){
  for(const group of ['w1','w2']){
    const pl = state.placed[group];
    if(!pl) continue;
    if(idx >= pl.start && idx < pl.start + TR){
      return {group, start: pl.start, tri: pl.tri, offset: idx - pl.start};
    }
  }
  return null;
}
function singleAt(idx){
  return state.singles.find(s => s.idx === idx) || null;
}
function cellChar(idx){
  const t = trigramAtIndex(idx);
  if(t) return t.tri[t.offset];
  const s = singleAt(idx);
  if(s) return s.ch;
  return "";
}
function removeSinglesInCells(cells){
  const set = new Set(cells);
  state.singles = state.singles.filter(s => !set.has(s.idx));
}

function focusCell(idx){
  const n = getN();
  const i = clamp(idx, 0, n-1);
  state.focusIdx = i;
  if(state.useCustomKB) return;
  const inp = el.grid.querySelector(`input[data-idx="${i}"]`);
  if(inp) inp.focus({preventScroll:true});
}

function nextEditableFrom(startIdx, dir){
  const n = getN();
  let i = clamp(startIdx, 0, n-1);
  while(i >= 0 && i < n){
    if(!trigramAtIndex(i)) return i;
    i += dir;
  }
  return null;
}
function typeLetterAtIndex(idx, ch){
  const n = getN();
  const lower = ch.toLowerCase();
  state.singles = state.singles.filter(x => x.idx !== idx);
  state.singles.push({id: uid(), ch: lower, idx});
  const next = nextEditableFrom(idx + 1, +1);
  state.focusIdx = (next == null) ? clamp(idx + 1, 0, n-1) : next;
}

function typeLetterIntoGrid(letter){
  if(state.finished) return;
  const ch = String(letter || "").slice(0,1);
  if(!isAlpha(ch)) return;

  const n = getN();
  let idx = clamp(state.focusIdx ?? 0, 0, n-1);
  if(trigramAtIndex(idx)){
    const found = nextEditableFrom(idx, +1);
    if(found == null) return;
    idx = found;
  }
  typeLetterAtIndex(idx, ch);
  render();
}

function deleteTrigramGroup(group){
  if(!state.placed[group]) return false;
  const start = state.placed[group].start;
  state.placed[group] = null;
  state.focusIdx = clamp(start, 0, getN()-1);
  return true;
}
function deleteAtIndex(idx){
  const t = trigramAtIndex(idx);
  if(t) return deleteTrigramGroup(t.group);
  const s = singleAt(idx);
  if(s){
    state.singles = state.singles.filter(x => x.idx !== idx);
    state.focusIdx = clamp(idx, 0, getN()-1);
    return true;
  }
  return false;
}
function kbBackspace(){
  if(state.finished) return;
  const n = getN();
  const idx = clamp(state.focusIdx ?? 0, 0, n-1);
  const tHere = trigramAtIndex(idx);
  if(tHere){
    deleteTrigramGroup(tHere.group);
    render();
    return;
  }
  if(singleAt(idx)){
    deleteAtIndex(idx);
    render();
    return;
  }
  if(idx === 0) return;
  if(deleteAtIndex(idx - 1)){ render(); return; }
  state.focusIdx = clamp(idx - 1, 0, n-1);
  render();
}

/* =======================
   Placement / cycling
   ======================= */
function placeTrigram(group, tri){
  if(state.finished) return;
  const t = norm(tri);
  if(!t || t.length !== 3) return;

  const n = getN();
  const otherGroup = group === 'w1' ? 'w2' : 'w1';
  const other = state.placed[otherGroup];

  const focus = clamp(state.focusIdx ?? 0, 0, n-1);
  const prefStart = clamp(focus, 0, startMax());

  const order = [prefStart];
  for(let d=1; d<=startMax(); d++){
    if(prefStart-d >= 0) order.push(prefStart-d);
    if(prefStart+d <= startMax()) order.push(prefStart+d);
  }

  let start = state.placed[group]?.start ?? null;

  function okAt(s){
    if(other){
      const ol = overlapCount(s, other.start);
      if(ol > 1) return false;
      if(ol === 1 && !overlapIsValid(s, t, other.start, other.tri)) return false;
    }
    return true;
  }

  if(start == null || !okAt(start)){
    start = null;
    for(const s of order){
      if(okAt(s)){ start = s; break; }
    }
  }
  if(start == null){
    setTransientMsg("can’t place", 1600);
    return;
  }

  state.placed[group] = {start, tri:t};
  removeSinglesInCells(trigramCells(start));
}

function firstTrigramOfWord(group){
  const p = current();
  const w = norm(group==='w1' ? p.word1 : p.word2);
  if(w.length < 3) return null;
  return w.slice(0,3);
}

function cyclePlacedTrigram(group){
  const p = current();
  const w = norm(group==='w1' ? p.word1 : p.word2);
  const max = Math.max(0, w.length - 3);
  if(max === 0) return;

  state.cycleCount++;

  let s = (group==='w1' ? state.sel1 : state.sel2) || 0;
  s = (s + 1) % (max + 1);
  if(group==='w1') state.sel1 = s; else state.sel2 = s;

  placeTrigram(group, w.slice(s, s+3));
}

function hint3Letters(){
  const p = current();
  const ans = norm(p.answer);
  const t1 = norm(p.tri1);
  const t2 = norm(p.tri2);

  let p1 = ans.indexOf(t1);
  if(p1 < 0) p1 = 0;

  let p2 = ans.indexOf(t2);
  if(p2 < 0) p2 = 0;
  if(p2 === p1){
    const next = ans.indexOf(t2, p2 + 1);
    if(next !== -1) p2 = next;
  }

  const covered = new Set();
  for(let k=0;k<3;k++) covered.add(p1+k);
  for(let k=0;k<3;k++) covered.add(p2+k);

  const leftover = [];
  for(let i=0;i<ans.length;i++){
    if(!covered.has(i)) leftover.push(ans[i]);
  }
  leftover.sort();
  return leftover;
}

function rebuildBank(){
  state.bank = hint3Letters().map(ch => ({id: uid(), ch}));
}

/* =======================
   Validation (max3 + two-trigrams + exclusions)
   ======================= */
function computeInvalidSets(){
  state.badSet = new Set();
  state.twoSet = new Set();
  state.exclSet = new Set();

  const n = getN();
  const p = current();
  const w1 = norm(p.word1);
  const w2 = norm(p.word2);

  const chars = Array.from({length:n}, (_,i)=>cellChar(i));
  // max3 contiguous substring from w1/w2 (length >=4)
  let i=0;
  while(i<n){
    if(!chars[i]){ i++; continue; }
    let j=i;
    while(j<n && chars[j]) j++;
    const run = chars.slice(i,j).join("").toLowerCase();
    if(run.length >= 4){
      for(let a=0; a<run.length; a++){
        for(let b=a+4; b<=run.length; b++){
          const s = run.slice(a,b);
          if((w1 && w1.includes(s)) || (w2 && w2.includes(s))){
            for(let k=i+a; k<i+b; k++) state.badSet.add(k);
          }
        }
      }
    }
    i=j;
  }

  // two trigrams from same word
  const occ = {w1:[], w2:[]};
  for(let s=0; s<=n-3; s++){
    if(!chars[s] || !chars[s+1] || !chars[s+2]) continue;
    const tri = (chars[s]+chars[s+1]+chars[s+2]).toLowerCase();
    if(w1 && w1.includes(tri)) occ.w1.push(s);
    if(w2 && w2.includes(tri)) occ.w2.push(s);
  }
  if(occ.w1.length >= 2){
    for(const s of occ.w1) for(const k of trigramCells(s)) state.twoSet.add(k);
  }
  if(occ.w2.length >= 2){
    for(const s of occ.w2) for(const k of trigramCells(s)) state.twoSet.add(k);
  }

  // hint exclusions
  if(state.hintsUsed.w1){
    const locked = norm(p.tri1);
    for(let s=0; s<=n-3; s++){
      if(!chars[s] || !chars[s+1] || !chars[s+2]) continue;
      const tri = (chars[s]+chars[s+1]+chars[s+2]).toLowerCase();
      if(tri !== locked && w1 && w1.includes(tri)){
        for(const k of trigramCells(s)) state.exclSet.add(k);
      }
    }
  }
  if(state.hintsUsed.w2){
    const locked = norm(p.tri2);
    for(let s=0; s<=n-3; s++){
      if(!chars[s] || !chars[s+1] || !chars[s+2]) continue;
      const tri = (chars[s]+chars[s+1]+chars[s+2]).toLowerCase();
      if(tri !== locked && w2 && w2.includes(tri)){
        for(const k of trigramCells(s)) state.exclSet.add(k);
      }
    }
  }
}

function overlapActiveNow(){
  const a = state.placed.w1, b = state.placed.w2;
  if(!a || !b) return false;
  if(overlapCount(a.start, b.start) !== 1) return false;
  return overlapIsValid(a.start, a.tri, b.start, b.tri);
}

function updateStatusMsg(){
  if(state.finished) return;
  if(state.msgTransient) return;

  computeInvalidSets();
  if(state.badSet.size){
    setMsg("Max 3 contiguous letters allowed", "warn"); return;
  }
  if(state.twoSet.size){
    setMsg(TWOTRI_TEXT, "warn"); return;
  }
  if(state.exclSet.size){
    setMsg("Your hint excluded this trigram", "warn"); return;
  }
  if(overlapActiveNow()){
    setMsg(OVERLAP_TEXT, null); return;
  }
  if(el.msg.classList.contains('warn') || el.msg.textContent === OVERLAP_TEXT) setMsg("");
}

/* =======================
   Hint track UI
   ======================= */
function makeTrigramBlock(tri, cls, onTap){
  const box = document.createElement('div');
  box.className = "letters clickable";
  for(const ch of tri){
    const d = document.createElement('div');
    d.className = "letter " + cls;
    d.textContent = ch;
    box.appendChild(d);
  }
  box.addEventListener('click', (e)=>{ e.preventDefault(); onTap?.(); });
  return box;
}

function renderHintTrack(){
  const p = current();
  el.trackW1.innerHTML = "";
  el.trackW2.innerHTML = "";
  el.trackExtras.innerHTML = "";

  if(state.hintsUsed.w1){
    const b = makeTrigramBlock(norm(p.tri1), "sel-w1", ()=>{
      placeTrigram('w1', norm(p.tri1));
      render();
    });
    el.trackW1.appendChild(b);
  }

  if(state.hintsUsed.w2){
    const b = makeTrigramBlock(norm(p.tri2), "sel-w2", ()=>{
      placeTrigram('w2', norm(p.tri2));
      render();
    });
    el.trackW2.appendChild(b);
  }

  if(state.hintsUsed.extras){
    if(!state.bank.length) rebuildBank();
    const row = document.createElement('div');
    row.className = "extrasRow";
    for(const tile of state.bank){
      const wrap = document.createElement('div');
      wrap.className = "letters clickable";
      const d = document.createElement('div');
      d.className = "letter extra";
      d.textContent = tile.ch;
      d.addEventListener('click', (e)=>{
        e.preventDefault();
        if(state.finished) return;
        const n = getN();
        for(let i=0;i<n;i++){
          if(cellChar(i)) continue;
          typeLetterAtIndex(i, tile.ch);
          render();
          return;
        }
        setTransientMsg("No blank spot", 1400);
      });
      wrap.appendChild(d);
      row.appendChild(wrap);
    }
    el.trackExtras.appendChild(row);
  }
}

/* =======================
   Render clue
   ======================= */
function splitClueTwoWords(clue){
  const s = String(clue||"").trim();
  const m = s.match(/^(\S+)\s+(\S+)\s*$/);
  if(m) return [m[1], m[2]];
  const parts = s.split(/\s+/).filter(Boolean);
  return [parts[0]||"", parts[1]||""];
}

function renderClue(){
  const p = current();
  const [c1,c2] = splitClueTwoWords(p.clue);
  const n = getN();
  el.clue.innerHTML = `
    <span class="clueWord" data-group="w1">${c1}</span>
    <span class="clueWord" data-group="w2"> ${c2}</span>
    <span class="len">${n}</span>
  `;

  el.clue.querySelectorAll('.clueWord').forEach(node=>{
    node.addEventListener('pointerdown', (e)=>{
      e.preventDefault();
      if(state.finished) return;
      const group = node.dataset.group;
      if(group !== 'w1' && group !== 'w2') return;

      if(state.placed[group]){
        cyclePlacedTrigram(group);
      }else{
        // if hinted, prefer locked trigram; else first trigram
        let tri = null;
        if(group==='w1' && state.hintsUsed.w1) tri = norm(p.tri1);
        if(group==='w2' && state.hintsUsed.w2) tri = norm(p.tri2);
        if(!tri) tri = firstTrigramOfWord(group);
        if(tri) placeTrigram(group, tri);
      }
      render();
    }, {passive:false});
  });
}

/* =======================
   Render grid
   ======================= */
function renderGrid(){
  const n = getN();
  computeInvalidSets();

  el.grid.style.setProperty('--n', String(n));
  el.grid.innerHTML = "";

  for(let i=0;i<n;i++){
    const cell = document.createElement('div');
    cell.className = "cell";
    cell.dataset.idx = String(i);

    if(!state.finished && i === clamp(state.focusIdx ?? 0, 0, n-1)){
      cell.classList.add('active');
    }

    const tri = trigramAtIndex(i);
    if(!state.finished && tri){
      // overlap green
      const ol = overlapActiveNow();
      if(ol){
        const common = overlapMatchIdx(state.placed.w1.start, state.placed.w2.start);
        if(common === i) cell.classList.add('bg-ol');
        else cell.classList.add(tri.group==='w1' ? 'bg-w1' : 'bg-w2');
      }else{
        cell.classList.add(tri.group==='w1' ? 'bg-w1' : 'bg-w2');
      }
      cell.classList.add('grabbable');
    }

    if(!state.finished && (state.badSet.has(i) || state.twoSet.has(i) || state.exclSet.has(i))){
      cell.classList.add('bg-bad');
    }

    const input = document.createElement('input');
    input.type = "text";
    input.inputMode = "none";
    input.autocapitalize = "none";
    input.autocomplete = "off";
    input.autocorrect = "off";
    input.spellcheck = false;
    input.maxLength = 1;
    input.dataset.idx = String(i);
    input.value = cellChar(i);
    input.readOnly = !!tri || state.useCustomKB || state.finished;

    input.addEventListener('focus', ()=>{ state.focusIdx = i; });

    input.addEventListener('keydown', (e)=>{
      if(state.finished) return;
      if(e.key === "ArrowLeft"){ e.preventDefault(); focusCell(i-1); render(); return; }
      if(e.key === "ArrowRight"){ e.preventDefault(); focusCell(i+1); render(); return; }
      if(e.key === "Backspace" || e.key === "Delete"){ e.preventDefault(); kbBackspace(); return; }

      if(e.key && e.key.length === 1 && isAlpha(e.key) && !input.readOnly){
        e.preventDefault();
        typeLetterAtIndex(i, e.key);
        render();
        return;
      }
      if(e.key === "Enter"){
        e.preventDefault();
        onCheck();
      }
    });

    cell.addEventListener('pointerdown', (e)=>{
      if(state.finished) return;
      e.preventDefault();
      state.focusIdx = i;
      if(!state.useCustomKB) focusCell(i);

      // simple drag of trigrams
      const t = trigramAtIndex(i);
      if(t){
        beginDrag(e, t.group, t.tri, i, t.start);
      }else{
        render();
      }
    }, {passive:false});

    cell.appendChild(input);
    el.grid.appendChild(cell);
  }
}

function beginDrag(e, group, tri, idx0, start0){
  if(state.finished) return;
  const ghost = document.createElement('div');
  ghost.className = "ghost";
  ghost.textContent = tri;
  ghost.style.width = "112px";
  ghost.style.height = "40px";
  ghost.style.display = "flex";
  ghost.style.alignItems = "center";
  ghost.style.justifyContent = "center";
  ghost.style.borderRadius = "12px";
  ghost.style.border = "4px solid var(--ink)";
  ghost.style.fontWeight = "900";
  ghost.style.fontStyle = "italic";
  ghost.style.letterSpacing = ".18em";
  ghost.style.textTransform = "lowercase";
  ghost.style.background = (group==='w1') ? "var(--w1)" : "var(--w2)";
  document.body.appendChild(ghost);

  const drag = {
    group, tri,
    grabOffset: idx0 - start0,
    ghost,
    lastStart: start0
  };
  state.drag = drag;

  const move = (ev)=>{
    if(!state.drag) return;
    ghost.style.left = ev.clientX + "px";
    ghost.style.top  = ev.clientY + "px";

    const rect = el.gridWrap.getBoundingClientRect();
    if(ev.clientX < rect.left || ev.clientX > rect.right || ev.clientY < rect.top || ev.clientY > rect.bottom){
      return;
    }

    // find closest cell index
    const cellEls = Array.from(el.grid.querySelectorAll('.cell'));
    let best = null;
    for(const c of cellEls){
      const r = c.getBoundingClientRect();
      const cx = (r.left+r.right)/2;
      const cy = (r.top+r.bottom)/2;
      const dx = ev.clientX - cx;
      const dy = ev.clientY - cy;
      const d2 = dx*dx+dy*dy;
      if(best==null || d2<best.d2) best = {idx:Number(c.dataset.idx), d2};
    }
    if(!best) return;

    const desired = clamp(best.idx - drag.grabOffset, 0, startMax());
    const mine = state.placed[group];
    if(!mine) return;

    const otherGroup = group==='w1' ? 'w2' : 'w1';
    const other = state.placed[otherGroup];

    if(other){
      const ol = overlapCount(desired, other.start);
      if(ol > 1) return;
      if(ol === 1 && !overlapIsValid(desired, mine.tri, other.start, other.tri)) return;
    }

    mine.start = desired;
    removeSinglesInCells(trigramCells(desired));
    drag.lastStart = desired;
    render();
  };

  const up = ()=>{
    window.removeEventListener('pointermove', move);
    window.removeEventListener('pointerup', up);
    try{ ghost.remove(); }catch{}
    state.drag = null;
  };

  window.addEventListener('pointermove', move, {passive:false});
  window.addEventListener('pointerup', up, {once:true});
}

/* =======================
   Buttons
   ======================= */
function canEnableCheckNow(){
  const n = getN();
  for(let i=0;i<n;i++) if(!cellChar(i)) return false;
  return true;
}

function renderButtons(){
  // hint label
  const h = state.hintCount;
  el.hintsBtn.textContent = (h < 3) ? `hint ${h+1}` : "give up";
  el.hintsBtn.disabled = state.finished;

  // check
  const ok = canEnableCheckNow() && !state.finished;
  el.checkBtn.classList.toggle('ready', ok);
  el.checkBtn.disabled = !ok;
}

function simpleSkill(){
  // lightweight skill (you can swap back to your full formula)
  const base = 100;
  const hintPenalty = state.hintCount * 15;
  const wrongPenalty = state.wrongCheckCount * 4;
  const cyclePenalty = state.cycleCount * 1;
  const raw = base - hintPenalty - wrongPenalty - cyclePenalty;
  return clamp(Math.round(raw), 25, 100);
}

function onHint(){
  if(state.finished) return;

  if(state.hintCount === 0){
    state.hintsUsed.w1 = true;
    state.hintCount = 1;
    placeTrigram('w1', norm(current().tri1));
    rebuildBank();
    render();
    return;
  }
  if(state.hintCount === 1){
    state.hintsUsed.w2 = true;
    state.hintCount = 2;
    placeTrigram('w2', norm(current().tri2));
    rebuildBank();
    render();
    return;
  }
  if(state.hintCount === 2){
    state.hintsUsed.extras = true;
    state.hintCount = 3;
    rebuildBank();
    render();
    return;
  }

  // give up
  revealAnswerGiveUp();
}

function onCheck(){
  if(state.finished) return;
  if(!canEnableCheckNow()) return;

  computeInvalidSets();
  if(state.badSet.size || state.twoSet.size || state.exclSet.size){
    shakeGrid();
    updateStatusMsg();
    return;
  }

  const n = getN();
  const attempt = Array.from({length:n}, (_,i)=>cellChar(i)).join("").toLowerCase();
  const ans = norm(current().answer);

  if(attempt === ans){
    state.finished = true;
    state.gaveUp = false;
    el.wrap.classList.add('solved');
    setMsg(`Correct — with ${state.hintCount} hint${state.hintCount===1?'':'s'}!\nSkill ${simpleSkill()}`, "result");
    render();
    return;
  }

  state.wrongCheckCount++;
  shakeGrid();
  setTransientMsg("Not quite", 1000);
  render();
}

function shakeGrid(){
  el.gridDock.classList.remove('shake');
  void el.gridDock.offsetWidth;
  el.gridDock.classList.add('shake');
  setTimeout(()=> el.gridDock.classList.remove('shake'), 420);
}

function revealAnswerGiveUp(){
  const ans = norm(current().answer);
  const n = getN();
  state.placed = {w1:null, w2:null};
  state.singles = [];
  for(let i=0;i<n;i++){
    state.singles.push({id: uid(), ch: ans[i]||"", idx:i});
  }
  state.focusIdx = 0;
  state.finished = true;
  state.gaveUp = true;
  el.wrap.classList.add('solved','gaveup');
  setMsg(`You gave up.\nSkill ${simpleSkill()}`, "result");
  render();
}

/* =======================
   Keyboard
   ======================= */
function shouldUseCustomKB(){
  const coarse = window.matchMedia && window.matchMedia('(pointer:coarse)').matches;
  const small  = window.matchMedia && window.matchMedia('(max-width: 920px)').matches;
  return !!(coarse && small);
}
function setCustomKBEnabled(on){
  state.useCustomKB = !!on;
  document.documentElement.classList.toggle('has-kb', state.useCustomKB);
  buildKeyboard();
  requestAnimationFrame(updateKeyboardHeightVar);
}
function updateKeyboardHeightVar(){
  if(!state.useCustomKB) return;
  const rect = el.kbHost.getBoundingClientRect();
  if(rect && rect.height){
    document.documentElement.style.setProperty('--kb-h', `${Math.ceil(rect.height)}px`);
  }
}

function pressKeyAction(kind, val){
  if(state.finished) return;
  if(kind === 'letter') typeLetterIntoGrid(val);
  else if(kind === 'delete') kbBackspace();
  else if(kind === 'enter') onCheck();
}

function makeKey(label, cls, kind, val){
  const b = document.createElement('button');
  b.type = "button";
  b.className = `kbKey ${cls||""}`.trim();
  b.textContent = label;

  b.addEventListener('pointerdown', (e)=>{
    e.preventDefault();
    if(b.classList.contains('is-disabled')) return;
    pressKeyAction(kind, val);
  }, {passive:false});

  return b;
}

function buildKeyboard(){
  el.kbHost.innerHTML = "";
  if(!state.useCustomKB) return;

  const kb = document.createElement('div');
  kb.className = "kb";

  ["QWERTYUIOP","ASDFGHJKL"].forEach((row)=>{
    const r = document.createElement('div');
    r.className = "kbRow";
    for(const ch of row){
      r.appendChild(makeKey(ch, "", "letter", ch.toLowerCase()));
    }
    kb.appendChild(r);
  });

  const r3 = document.createElement('div');
  r3.className = "kbRow";
  r3.appendChild(makeKey("CHECK", "wide enter", "enter", null));
  for(const ch of "ZXCVBNM"){
    r3.appendChild(makeKey(ch, "", "letter", ch.toLowerCase()));
  }
  r3.appendChild(makeKey("DEL", "wide delete", "delete", null));
  kb.appendChild(r3);

  el.kbHost.appendChild(kb);
}

/* =======================
   Main render + puzzle nav
   ======================= */
function render(){
  renderClue();
  renderGrid();
  renderHintTrack();
  renderButtons();
  updateStatusMsg();
  el.count.textContent = `${state.i+1}/${PUZZLES.length}`;
}

function resetForPuzzle(idx){
  state.i = (idx + PUZZLES.length) % PUZZLES.length;
  state.finished = false;
  state.gaveUp = false;
  state.hintCount = 0;
  state.hintsUsed = {w1:false, w2:false, extras:false};
  state.placed = {w1:null, w2:null};
  state.singles = [];
  state.focusIdx = 0;
  state.sel1 = 0;
  state.sel2 = 0;
  state.wrongCheckCount = 0;
  state.cycleCount = 0;
  state.bank = [];
  el.wrap.classList.remove('solved','gaveup');
  setMsg("");
  rebuildBank();
  render();
}

el.hintsBtn.addEventListener('click', (e)=>{ e.preventDefault(); onHint(); });
el.checkBtn.addEventListener('click', (e)=>{ e.preventDefault(); onCheck(); });

el.prevBtn.addEventListener('click', (e)=>{ e.preventDefault(); resetForPuzzle(state.i - 1); });
el.nextBtn.addEventListener('click', (e)=>{ e.preventDefault(); resetForPuzzle(state.i + 1); });

/* IMPORTANT: background tap toggle excluded from dock downward */
document.addEventListener('pointerup', (e)=>{
  if(state.finished) return;
  if(state.drag) return;
  if(performance.now() - (state.justDraggedAt||0) < 350) return;

  const dock = el.bottomDock.getBoundingClientRect();
  if(dock && e.clientY >= (dock.top - 6)) return;  // <-- key change vs btnRow-only

}, {passive:true, capture:true});

/* init */
setCustomKBEnabled(shouldUseCustomKB());
window.addEventListener('resize', ()=>{
  const next = shouldUseCustomKB();
  if(next !== state.useCustomKB) setCustomKBEnabled(next);
  else updateKeyboardHeightVar();
});
resetForPuzzle(0);
</script>
</body>
</html>
