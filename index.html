<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Trigram Demo</title>

  <style>
    :root{
      --bg:#a9cdf3;
      --bubble:#fff;
      --ink:#0b0b0b;

      --w1:#fff3b3;   /* yellow */
      --w2:#cfe8ff;   /* blue */
      --ol:#c9f3d6;   /* green */
      --bad:#ffc9d2;  /* red/pink warning */
      --submit:#F4D2FD;

      /* keyboard */
      --kb-h: 260px; /* JS sets real height */
      --caret: rgba(0,0,0,.18);
    }

    *{ box-sizing:border-box; }
    html, body{
      height:100%;
      overflow:hidden;
      overscroll-behavior:none;
      background:var(--bg);
    }
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
      color:var(--ink);
      text-align:center;
      -webkit-text-size-adjust: 100%;
    }

    /* disable native selection/callout on interactive UI */
    #clue, #clue *,
    #gridWrap, #gridWrap *,
    #hintTrack, #hintTrack *,
    #btnRow, #btnRow *,
    #kbHost, #kbHost *,
    #hintModal, #hintModal *{
      -webkit-user-select:none;
      user-select:none;
      -webkit-touch-callout:none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    .wrap{
      height:100dvh;
      max-height:100dvh;
      width:100%;
      max-width:980px;
      margin:0 auto;
      padding:12px 14px 14px;
      display:flex;
      flex-direction:column;
      align-items:stretch;
      justify-content:flex-start;
      overflow:hidden;
      position:relative;
    }

    /* ====== Top nav ====== */
    .toprow{
      display:flex;
      justify-content:center;
      align-items:center;
      margin-top:2px;
      flex:0 0 auto;
    }
    .nav{
      display:flex;
      align-items:center;
      gap:10px;
      font-weight:900;
    }
    .nav a, .nav button{
      color:var(--ink);
      text-decoration:none;
      font-weight:900;
      padding:5px 10px;
      border-radius:999px;
      background:rgba(255,255,255,.32);
      border:2px solid rgba(0,0,0,.16);
      cursor:pointer;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      appearance:none;
      -webkit-appearance:none;
      font:inherit;
    }
    .nav a:active, .nav button:active{ transform:translateY(1px); }
    .count{ font-weight:900; opacity:.7; min-width:58px; text-align:center; }

    /* ====== Clue ====== */
    .clue{
      display:block;
      width:fit-content;
      max-width:min(940px,94vw);
      margin: clamp(18px, 3.6vh, 36px) auto 0;
      padding:14px 13px 15px 20px;
      background:var(--bubble);
      border-radius:18px;
      box-shadow:0 2px 6px rgba(0,0,0,.08);
      font-size:clamp(30px,5.4vw,38px);
      line-height:1.12;
      letter-spacing:.12px;
      font-weight:400;
      flex:0 0 auto;
    }
    .clue .len{
      opacity:.55;
      font-weight:inherit;
      font-style:inherit;
      display:inline-block;
      font-size:0.92em;
      line-height:1;
      vertical-align:middle;
      position: relative;
      top: -0.1em;
      margin-left:8px;
    }

    .clueWord{
      display:inline-block;
      cursor:pointer;
      user-select:none;
      touch-action: manipulation;
      font-kerning: none;
      font-variant-ligatures: none;
      font-feature-settings: "kern" 0, "liga" 0, "clig" 0;
    }
    .wrap.no-assist .clueWord{ cursor:default; }

    .u-w1, .u-w2, .u-red{
      text-decoration: underline;
      text-decoration-thickness: 6px;
      text-underline-offset: 9px;
      pointer-events: none;
    }
    .u-w1{ text-decoration-color: rgba(255,220,0,.9); }
    .u-w2{ text-decoration-color: rgba(70,160,255,.92); }
    .u-red{ text-decoration-color: rgba(235,80,92,.92); }

    /* ====== Grid ====== */
    .gridWrap{
      display:block;
      width:fit-content;
      margin: clamp(38px, 6.0vh, 58px) auto 0;
      border:4px solid var(--ink);
      border-radius:14px;
      overflow:hidden;
      background:#fff;
      box-shadow:0 3px 8px rgba(0,0,0,.08);
      transition: box-shadow .45s ease;
      will-change: transform, box-shadow;
      flex:0 0 auto;
    }
    @media (pointer:coarse) and (max-width: 920px){
      .gridWrap{ margin-top: clamp(36px, 6.1vh, 62px); }
    }
    html.has-kb .gridWrap{
      margin: clamp(52px, 8.0vh, 86px) auto 0;
    }

    .gridWrap.shake{ animation:shake .16s linear 0s 2; }

    .wrap.solved .gridWrap{
      pointer-events:none;
      transform: translate3d(0,18px,0) scale(1.01);
      box-shadow:
        0 0 0 7px rgba(200,247,210,.55),
        0 0 0 13px rgba(200,247,210,.22),
        0 14px 26px rgba(0,0,0,.14);
      animation:
        solvedPop .46s ease-out both,
        glowPulse 1.15s ease-in-out 0s 2;
    }
    .wrap.solved .cell{ background:#fff !important; }
    .wrap.solved .hintTrack{ opacity:0.35; }
    .wrap.solved .btnRow{ opacity:0.55; pointer-events:none; }

    @keyframes solvedPop{
      0%{ transform: translate3d(0,8px,0) scale(.985); }
      55%{ transform: translate3d(0,20px,0) scale(1.02); }
      100%{ transform: translate3d(0,18px,0) scale(1.01); }
    }
    @keyframes glowPulse{
      0%{
        box-shadow:
          0 0 0 7px rgba(200,247,210,.40),
          0 0 0 13px rgba(200,247,210,.16),
          0 14px 26px rgba(0,0,0,.14);
      }
      50%{
        box-shadow:
          0 0 0 7px rgba(200,247,210,.70),
          0 0 0 14px rgba(200,247,210,.28),
          0 16px 30px rgba(0,0,0,.16);
      }
      100%{
        box-shadow:
          0 0 0 7px rgba(200,247,210,.55),
          0 0 0 13px rgba(200,247,210,.22),
          0 14px 26px rgba(0,0,0,.14);
      }
    }
    @keyframes shake{
      0%{ transform:translateX(0); }
      25%{ transform:translateX(-6px); }
      50%{ transform:translateX(6px); }
      75%{ transform:translateX(-4px); }
      100%{ transform:translateX(0); }
    }

    .grid{
      --n: 7;
      --gap: 3px;
      --cell: 44px;
      display:grid;
      grid-template-columns:repeat(var(--n), 1fr);
      gap: var(--gap);
      background: var(--ink);
      width: min(calc(var(--n) * var(--cell) + (var(--n) - 1) * var(--gap)), 92vw);
    }
    .cell{
      aspect-ratio:1/1;
      display:flex;
      align-items:center;
      justify-content:center;
      background:#fff;
      position:relative;
    }
    .cell.active::after{
      content:"";
      position:absolute;
      height:3px;
      width:62%;
      left:50%;
      bottom:12%;
      transform:translateX(-50%);
      background:var(--caret);
      border-radius:999px;
      animation: caretBlink 1.1s steps(2,end) infinite;
      pointer-events:none;
      opacity:1;
    }
    @keyframes caretBlink{
      0%, 46%{ opacity:1; }
      47%, 100%{ opacity:0; }
    }

    .cell input{
      width:100%;
      height:100%;
      border:0; outline:none;
      background:transparent;
      text-align:center;
      font-size:clamp(23px,5.1vw,32px);
      font-weight:900;
      font-style:italic;
      padding:0; margin:0;
      color:var(--ink);
      text-transform:lowercase;
      caret-color: transparent;
      cursor:text;
      appearance:none;
      -webkit-appearance:none;
      border-radius:0;
      -webkit-tap-highlight-color: transparent;
      user-select:none;
      -webkit-user-select:none;
    }
    .cell input::selection{ background:transparent; color:inherit; }

    /* Grid colouring (ONLY after Quick controls hint taken) */
    .cell.bg-w1{ background:var(--w1); }
    .cell.bg-w2{ background:var(--w2); }
    .cell.bg-ol{ background:var(--ol); }
    .cell.bg-bad{ background:var(--bad) !important; }

    .cell.grabbable{ cursor:grab; }
    .cell.grabbable:active{ cursor:grabbing; }
    .cell.grabbable input{ pointer-events:none; cursor:grab; }

    html.has-kb .cell input{ pointer-events:none; }

    /* ===== Messages ===== */
    .msgSlot{
      position:relative;
      height:74px;
      width:100%;
      max-width:760px;
      margin: clamp(10px, 2.6vh, 18px) auto 0;
      user-select:none;
      flex:0 0 auto;
    }
    .msg{
      position:absolute;
      left:50%;
      transform:translateX(-50%);
      top:12px;
      margin:0;
      font-weight:900;
      opacity:0;
      transition:opacity .18s ease, transform .18s ease;
      font-style:italic;
      font-size:22px;
      pointer-events:none;
      width:max-content;
      max-width:min(92vw,760px);
      white-space:normal;
      line-height:1.15;
      text-align:center;
    }
    .msg.show{ opacity:.92; }
    .msg.warn{ opacity:.92; font-size:20px; }
    .msg.result{ top:22px; }

    /* ===== Hint tracker ===== */
    .hintTrack{
      margin: clamp(14px, 3.4vh, 24px) auto 0;
      width:fit-content;
      max-width:min(920px,96vw);
      min-height:78px;
      display:flex;
      align-items:center;
      justify-content:center;
      transition:opacity .35s ease;
      user-select:none;
      flex:0 0 auto;
    }
    .trackRow{
      display:flex;
      align-items:flex-start;
      justify-content:center;
      gap:18px;
      flex-wrap:nowrap;
    }
    .trackBlock{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:6px;
      min-width:0;
    }

    /* ===== Hint mini-grids (square tiles, no capsule) ===== */
    .letters{
      display:inline-flex;
      border:none;
      border-radius:0;
      background:transparent;
      overflow:visible;
      position:relative;
      flex:0 0 auto;
    }
    .letters.clickable{ cursor:pointer; }
    .letters.is-disabled{ opacity:1; cursor:default; }

    .letter{
      width:29px;
      height:29px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:900;
      font-style:italic;
      font-size:19px;
      text-transform:lowercase;
      position:relative;
      background:rgba(255,255,255,.35);
      transition:opacity .15s ease, background .15s ease, transform .08s ease;
      border:1px solid rgba(0,0,0,.22);
      border-radius:0;
    }
    .letter + .letter{ margin-left:-1px; }
    .letter.sel-w1{ background:var(--w1); }
    .letter.sel-w2{ background:var(--w2); }
    .letter.extra{
      background:rgba(255,255,255,.95);
      cursor:pointer;
      box-shadow:none;
      font-style:italic;
    }
    .letters.is-disabled .letter.extra{ cursor:default; }
    .letter.extra:active{ transform:translateY(1px); }

    .tinyLbl{
      font-size:12px;
      font-weight:900;
      color:#000;
      line-height:1;
      margin-top:2px;
      pointer-events:none;
      text-transform:lowercase;
      font-style:normal;
      opacity:.95;
      display:none;
    }
    .extrasRow{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:center;
      flex-wrap:nowrap;
    }

    /* ===== Buttons ===== */
    .btnRow{
      margin-top: clamp(18px, 3.8vh, 26px);
      display:flex;
      justify-content:center;
      gap:12px;
      flex-wrap:wrap;
      flex:0 0 auto;
      padding-bottom: 2px;
    }
    .btn{
      border:4px solid var(--ink);
      border-radius:999px;
      padding:9px 16px;
      min-width:104px;
      font-size:20px;
      font-weight:900;
      font-style:italic;
      color:var(--ink);
      background:rgba(255,255,255,.35);
      cursor:pointer;
      user-select:none;
      text-transform:none; /* allow GIVE UP */
      appearance:none;
      -webkit-appearance:none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      box-shadow: 0 7px 0 rgba(0,0,0,.16);
    }
    .btn:active{
      transform:translateY(1px);
      box-shadow: 0 6px 0 rgba(0,0,0,.16);
    }
    .btn.hints{ background:#fff3bd; }
    .btn.check{ background:rgba(255,255,255,.25); opacity:.55; }
    .btn.check.ready{ opacity:1; background:var(--submit); }
    .btn:disabled{
      opacity:.35 !important;
      cursor:default;
      transform:none !important;
      box-shadow: 0 7px 0 rgba(0,0,0,.10);
    }

    html.has-kb .btnRow{
      position:fixed;
      left:0; right:0;
      bottom: calc(var(--kb-h) + env(safe-area-inset-bottom) + 36px);
      margin:0;
      z-index:9997;
    }
    html.has-kb .btn{ border-width:3px; }

    /* ===== Ghost (drag overlay) ===== */
    .ghost{
      position:fixed;
      z-index:9999;
      pointer-events:none;
      transform: translate(-50%, -50%);
      filter: drop-shadow(0 14px 16px rgba(0,0,0,.22));
      opacity:.95;
    }

    /* ========= Custom On-screen Keyboard ========= */
    .kbHost{
      position:fixed;
      left:0; right:0;
      bottom:0;
      z-index:9996;
      display:none;
      padding:10px 10px calc(10px + env(safe-area-inset-bottom));
      background:rgba(255,255,255,.90);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border-top:2px solid rgba(0,0,0,.14);
      box-shadow:none;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      user-select:none;
      -webkit-user-select:none;
    }
    html.has-kb .kbHost{ display:block; }

    .kb{
      max-width:560px;
      margin:0 auto;
      display:flex;
      flex-direction:column;
      gap:8px;
      --keyW: clamp(28px, 8.6vw, 48px);
    }
    .kbRow{
      display:flex;
      justify-content:center;
      gap:4px;
    }
    .kbKey{
      width: var(--keyW);
      height: 48px;
      border:2px solid rgba(0,0,0,.16);
      border-radius:11px;
      background:rgba(255,255,255,.82);
      font-weight:700;
      font-style:normal;
      text-transform:none;
      font-size: 18px;
      color: var(--ink);
      box-shadow:none;
      cursor:pointer;
      user-select:none;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }
    .kbKey:active{ transform:translateY(1px); }
    .kbKey.wide{
      width: calc(var(--keyW) * 1.55);
      font-size: 12px;
      font-weight: 900;
      letter-spacing: .08em;
      padding: 0;
    }
    .kbKey.enter{
      font-size: 11px;
      letter-spacing: .02em;
    }
    .kbKey.enter:not(.is-disabled){
      background: rgba(0,0,0,.07);
    }
    .kbKey.delete{
      font-size: 16.3px;
      letter-spacing: 0.03em;
      font-weight:750;
      background: rgba(0,0,0,.07);
    }
    .kbKey.is-disabled{
      opacity:.38;
      background: rgba(0,0,0,.04);
      border-color: rgba(0,0,0,.10);
      transform:none !important;
      cursor:default;
    }

    @media (max-width:520px){
      .nav a, .nav button{ padding:4px 9px; }
      .clue{
        font-size:clamp(32px,6.6vw,38px);
        margin-top: clamp(16px, 3.4vh, 28px);
      }
      .grid{
        --cell: 43px;
        width: min(calc(var(--n) * var(--cell) + (var(--n) - 1) * var(--gap)), 94vw);
      }
      .cell input{ font-size:clamp(24px,6.05vw,36px); }
      .letter{ width:28px; height:28px; font-size:19px; }
      .msgSlot{ height:74px; }
      .msg{ font-size:20px; top:12px; }
      .msg.warn{ font-size:19px; }
      .btn{ font-size:19px; padding:9px 15px; min-width:98px; }
      .kbKey{ height:46px; }
    }

    /* ========= Hint modal ========= */
    .modalOverlay{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.26);
      display:none;
      align-items:center;
      justify-content:center;
      z-index:10000;
      padding: 14px;
    }
    .modalOverlay.open{ display:flex; }

    .modalCard{
      width: min(560px, 94vw);
      background:#fff;
      border-radius:18px;
      border:2px solid rgba(0,0,0,.15);
      box-shadow: 0 10px 26px rgba(0,0,0,.18);
      overflow:hidden;
      text-align:left;
      display:flex;
      flex-direction:column;
      max-height: calc(100dvh - 28px);
    }
    .modalHdr{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 14px 14px 12px;
      border-bottom:1px solid rgba(0,0,0,.08);
      flex:0 0 auto;
    }
    .modalTitle{
      font-weight: 950;
      font-size: 18px;
      letter-spacing: .01em;
    }

    /* subtle black X */
    .modalX{
      border:none;
      background:transparent;
      padding:0;
      margin:0;
      color:#000;
      font-size: 18px;
      font-weight: 950;
      line-height: 1;
      cursor:pointer;
      border-radius: 8px;
      opacity:.65;
    }
    .modalX:hover{ opacity:.9; }
    .modalX:active{ transform: translateY(1px); }
    .modalX:focus{ outline:none; }
    .modalX:focus-visible{
      outline: 2px solid rgba(0,0,0,.25);
      outline-offset: 2px;
    }

    .modalBody{
      padding: 12px 14px 14px;
      flex:1 1 auto;
      overflow:auto;
      text-align:left;
    }

    /* ===== Hint option rows (equal height, left-aligned titles) ===== */
    .hintOptRow{
      width:100%;
      border:2px solid rgba(0,0,0,.16);
      border-radius: 14px;
      padding: 12px 12px;
      background:#fff;
      display:flex;
      height: 82px;
      align-items:center;
      gap: 10px;
      margin: 10px 0;
      box-shadow:none;
    }
    .opt-quick{ background: var(--submit); }
    .opt-w1{ background: var(--w1); }
    .opt-w2{ background: var(--w2); }
    .opt-extras{ background: rgba(255,255,255,.95); }

    .hintOptMain{
      display:flex;
      flex-direction:column;
      justify-content:center;
      gap:4px;
      min-width:0;
      margin-right:auto;  /* IMPORTANT: prevents any “indent” */
      text-align:left;
    }
    .hintOptTitle{
      font-weight: 950;
      font-size: 16px;
      line-height:1.15;
      margin:0;
      padding:0;
      text-indent:0;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .hintOptSub{
      font-size: 13px;
      opacity:.78;
      line-height:1.25;
      display:-webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow:hidden;
    }

    .hintOptRight{
      display:flex;
      align-items:center;
      gap:10px;
      flex:0 0 auto;
    }
    .badge{
      flex:0 0 auto;
      padding: 5px 10px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 950;
      letter-spacing: .06em;
      border: 2px solid rgba(0,0,0,.14);
      background: rgba(255,255,255,.62);
      display:inline-flex;
      align-items:center;
      gap:6px;
      white-space:nowrap;
    }

    .optBtns{
      display:flex;
      gap:8px;
      align-items:center;
      justify-content:flex-end;
      flex:0 0 auto;
    }
    .optBtn{
      border:0;
      background:transparent;
      color:#000;
      font-weight:950;
      font-size: 12px;
      letter-spacing:.10em;
      padding: 6px 8px;
      border-radius:999px;
      cursor:pointer;
      opacity:.78;
      text-transform:uppercase;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }
    .optBtn:hover{ opacity:1; text-decoration:underline; text-underline-offset:3px; }
    .optBtn:active{ transform:translateY(1px); }
    .optBtn[disabled]{
      opacity:.35;
      cursor:default;
      text-decoration:none !important;
      transform:none !important;
    }

    /* ===== Detail view footer buttons ===== */
    .detailFooter{
      display:flex;
      justify-content:flex-end;
      gap:10px;
      margin-top: 14px;
      padding-top: 12px;
      border-top: 1px solid rgba(0,0,0,.08);
    }
    .detailBtn{
      border:2px solid rgba(0,0,0,.18);
      background: rgba(255,255,255,.7);
      border-radius:999px;
      padding:8px 12px;
      font-weight:950;
      letter-spacing:.08em;
      font-size:12px;
      text-transform:uppercase;
      cursor:pointer;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }
    .detailBtn.primary{
      background: rgba(0,0,0,.07);
    }
    .detailBtn:active{ transform:translateY(1px); }
    .detailBtn[disabled]{
      opacity:.38;
      cursor:default;
      transform:none !important;
    }

    .qcHelp ul{
      margin: 10px 0 0 18px;
      padding: 0;
      font-size: 15px;
      line-height: 1.35;
    }
    .qcHelp li{ margin: 8px 0; }
    .qcHelp .note{
      margin-top: 12px;
      font-size: 13px;
      opacity:.75;
    }

    .hintTilesInline{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      margin: 10px 0 0;
    }
  </style>
</head>

<body>
  <div class="wrap" id="wrap">
    <div class="toprow">
      <div class="nav">
        <a href="#" id="prevBtn" aria-label="Previous puzzle">‹</a>
        <span class="count" id="count"></span>
        <a href="#" id="nextBtn" aria-label="Next puzzle">›</a>
      </div>
    </div>

    <div class="clue" id="clue"></div>

    <div class="gridWrap" id="gridWrap" aria-label="Answer grid">
      <div class="grid" id="grid" style="--n:7"></div>
    </div>

    <div class="msgSlot" id="msgSlot" aria-live="polite">
      <div class="msg" id="msg"></div>
    </div>

    <div class="hintTrack" id="hintTrack" aria-label="Hint tracker">
      <div class="trackRow" id="trackRow">
        <div class="trackBlock" id="trackW1"></div>
        <div class="trackBlock" id="trackW2"></div>
        <div class="trackBlock" id="trackExtras"></div>
      </div>
    </div>

    <div class="btnRow" id="btnRow">
      <button class="btn hints" id="hintBtn" type="button">Hints</button>
      <button class="btn check" id="checkBtn" type="button">check</button>
    </div>
  </div>

  <!-- Hint modal -->
  <div class="modalOverlay" id="hintModal" aria-hidden="true">
    <div class="modalCard" role="dialog" aria-modal="true" aria-labelledby="hintModalTitle">
      <div class="modalHdr">
        <div class="modalTitle" id="hintModalTitle">Hints</div>
        <button class="modalX" id="hintModalClose" type="button" aria-label="Close">X</button>
      </div>
      <div class="modalBody" id="hintModalBody"></div>
    </div>
  </div>

  <div class="kbHost" id="kbHost" aria-label="On-screen keyboard"></div>

<script>
/* =======================
   Puzzles
   ======================= */
const PUZZLES = [
  { clue:"Beachy sights",     word1:"beachy",  word2:"sights",  answer:"yachts",  tri1:"ach", tri2:"hts" },
  { clue:"Believe oracle?",   word1:"believe", word2:"oracle",  answer:"clever",  tri1:"eve", tri2:"cle" },
  { clue:"Raccoon scuffle!",  word1:"raccoon", word2:"scuffle", answer:"buffoon", tri1:"oon", tri2:"uff" },
  { clue:"Tidal tiptoes",     word1:"tidal",   word2:"tiptoes", answer:"riptide", tri1:"tid", tri2:"ipt" },
  { clue:"Trusty boombox",    word1:"trusty",  word2:"boombox", answer:"combust", tri1:"ust", tri2:"omb" },
  { clue:"Wholly muscle?",    word1:"wholly",  word2:"muscle",  answer:"mollusc", tri1:"oll", tri2:"usc" },
  { clue:"Juicy muscles",     word1:"juicy",   word2:"muscles", answer:"bicycle", tri1:"icy", tri2:"cle" },
  { clue:"Perform, monkey!",  word1:"perform", word2:"monkey",  answer:"hormones", tri1:"orm", tri2:"one" },
];

const TR = 3;

const el = {
  wrap: document.getElementById('wrap'),
  clue: document.getElementById('clue'),
  gridWrap: document.getElementById('gridWrap'),
  grid: document.getElementById('grid'),
  msg: document.getElementById('msg'),

  trackW1: document.getElementById('trackW1'),
  trackW2: document.getElementById('trackW2'),
  trackExtras: document.getElementById('trackExtras'),

  hintBtn: document.getElementById('hintBtn'),
  checkBtn: document.getElementById('checkBtn'),

  prevBtn: document.getElementById('prevBtn'),
  nextBtn: document.getElementById('nextBtn'),
  count: document.getElementById('count'),

  kbHost: document.getElementById('kbHost'),

  hintModal: document.getElementById('hintModal'),
  hintModalTitle: document.getElementById('hintModalTitle'),
  hintModalBody: document.getElementById('hintModalBody'),
  hintModalClose: document.getElementById('hintModalClose'),
};

const TWOTRI_TEXT  = "Two trigrams from same word";
const OVERLAP_TEXT = "1-letter overlap allowed ✓";

/* =======================
   Hint system
   ======================= */
const HINT_IDS = {
  quick: 'quick',
  w1: 'w1',
  w2: 'w2',
  extras: 'extras'
};

function hintLabel(id){
  if(id === HINT_IDS.quick) return "Quick controls";
  if(id === HINT_IDS.w1) return "Word 1 trigram";
  if(id === HINT_IDS.w2) return "Word 2 trigram";
  if(id === HINT_IDS.extras) return "Extra letters";
  return "Hint";
}

/* =======================
   State
   ======================= */
const state = {
  i: 0,
  finished: false,
  showedAnswer: false,

  hintCount: 0,
  hintsUsed: { quick:false, w1:false, w2:false, extras:false },

  /* “assist features” unlocked by Quick controls only */
  assist: false,

  sel1: null,
  sel2: null,

  placed: { w1: null, w2: null },
  singles: [],
  bank: [],
  focusIdx: 0,

  drag: null,

  msgTimer: null,
  msgTransient: false,
  lockMsg: false,

  badSet: new Set(),
  badTris: { w1: new Set(), w2: new Set() },
  badRuns: { w1: [], w2: [] },

  twoSet: new Set(),
  twoTris: { w1: new Set(), w2: new Set() },

  exclSet: new Set(),
  exclTris: { w1: new Set(), w2: new Set() },

  overlapMsgOn: false,

  useCustomKB: false,

  modalOpen: false,
  modalView: 'list',        // 'list' | 'detail'
  modalHintId: null,        // which hint is being shown in detail view
  modalFixedH: null,
};

/* =======================
   Assist flags
   NOTE: messages are ALWAYS enabled (per your request)
   ======================= */
function flags(){
  if(state.assist){
    return {
      allowClueTapPlace: true,
      allowClueTapCycle: true,
      allowHintTapPlace: true,
      allowHint3TapInsert: true,
      allowDragTrigrams: true,
      allowAutoPromote: true,
      showGridColors: true,
      showStatusMessages: true,   // ALWAYS true, but kept explicit
      showBadCellColor: true,
      checkFeedback: "detailed",
    };
  }
  return {
    allowClueTapPlace: false,
    allowClueTapCycle: false,
    allowHintTapPlace: false,
    allowHint3TapInsert: false,
    allowDragTrigrams: false,
    allowAutoPromote: false,
    showGridColors: false,
    showStatusMessages: true,   // ALWAYS ON
    showBadCellColor: false,
    checkFeedback: "minimal",
  };
}

/* =======================
   Helpers
   ======================= */
function uid(){ return Math.random().toString(16).slice(2) + Date.now().toString(16); }
function clamp(n,min,max){ return Math.max(min, Math.min(max, n)); }
function current(){ return PUZZLES[state.i]; }
function norm(s){ return String(s||"").toLowerCase().replace(/[^a-z]/g,""); }
function isAlpha(ch){ return /^[a-z]$/i.test(ch); }
function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

function getN(){
  const a = norm(current().answer);
  return clamp(a.length || 7, 6, 8);
}
function startMax(){ return Math.max(0, getN() - TR); }

function renderSmart(){ render(!state.useCustomKB); }

function shakeGrid(){
  el.gridWrap.classList.remove('shake');
  void el.gridWrap.offsetWidth;
  el.gridWrap.classList.add('shake');
  setTimeout(()=> el.gridWrap.classList.remove('shake'), 420);
}

/* prevent context menu on interactive surface */
document.addEventListener('contextmenu', (e)=>{
  const t = e.target;
  if(t && t.closest && t.closest('#clue, #gridWrap, #hintTrack, #btnRow, #kbHost, #hintModal')){
    e.preventDefault();
  }
});

/* =======================
   Messages
   ======================= */
function clearMsgTimer(){
  if(state.msgTimer){ clearTimeout(state.msgTimer); state.msgTimer=null; }
  state.msgTransient = false;
}
function setMsg(text, kind){
  clearMsgTimer();
  el.msg.classList.remove('show','warn','result');
  el.msg.textContent = text || "";
  if(!text) return;
  void el.msg.offsetWidth;
  el.msg.classList.add('show');
  if(kind === 'warn') el.msg.classList.add('warn');
  if(kind === 'result') el.msg.classList.add('result');
}
function setTransientMsg(text, ms=2200){
  setMsg(text);
  state.msgTransient = true;
  state.msgTimer = setTimeout(()=>{
    el.msg.classList.remove('show','warn','result');
    el.msg.textContent = "";
    state.msgTimer = null;
    state.msgTransient = false;
  }, ms);
}
function clearTransientOnAnyChange(){
  if(state.lockMsg){
    state.lockMsg = false;
    setMsg("");
  }
  if(state.msgTransient){
    el.msg.classList.remove('show','warn','result');
    el.msg.textContent = "";
    clearMsgTimer();
  }
}
function excludedMsgText(){
  const n = (state.exclTris?.w1?.size || 0) + (state.exclTris?.w2?.size || 0);
  return (n >= 2) ? "Your hints excluded these trigrams" : "Your hint excluded this trigram";
}

/* =======================
   Clue helpers
   ======================= */
function splitClueTwoWords(clue){
  const s = String(clue||"").trim();
  const m = s.match(/^(\S+)\s+(\S+)\s*$/);
  if(m) return [m[1], m[2]];
  const parts = s.split(/\s+/).filter(Boolean);
  return [parts[0]||"", parts[1]||""];
}
function underlineBySubstrings(token, items){
  const chars = Array.from(token);
  const map=[];
  let clean="";
  for(let i=0;i<chars.length;i++){
    if(/[A-Za-z]/.test(chars[i])){ map.push(i); clean += chars[i].toLowerCase(); }
  }
  if(!clean) return escapeHtml(token);

  const clsAt = new Array(chars.length).fill(null);
  const prio = (cls)=> (cls === "u-red" ? 3 : (cls === "u-w1" || cls === "u-w2" ? 2 : 1));

  for(const it of items){
    const sub = norm(it.sub);
    if(!sub) continue;
    let pos = clean.indexOf(sub);
    while(pos >= 0){
      for(let k=0;k<sub.length;k++){
        const oi = map[pos+k];
        if(oi == null) continue;
        const cur = clsAt[oi];
        if(!cur || prio(it.cls) >= prio(cur)) clsAt[oi] = it.cls;
      }
      break;
    }
  }

  let out = "";
  let open = null;
  for(let i=0;i<chars.length;i++){
    const c = chars[i];
    const cls = clsAt[i];
    if(cls !== open){
      if(open) out += "</span>";
      if(cls) out += `<span class="${cls}">`;
      open = cls || null;
    }
    out += escapeHtml(c);
  }
  if(open) out += "</span>";
  return out;
}

/* =======================
   Grid model + focus
   ======================= */
function gridIndexFromPoint(x,y){
  const els = document.elementsFromPoint ? document.elementsFromPoint(x,y) : [document.elementFromPoint(x,y)];
  for(const n of els){
    if(!n) continue;
    const cell = n.closest ? n.closest('.cell') : null;
    if(cell && cell.dataset && cell.dataset.idx != null){
      const idx = Number(cell.dataset.idx);
      if(Number.isFinite(idx)) return idx;
    }
  }
  return null;
}
function trigramCells(start){ return [start, start+1, start+2]; }
function overlapCount(aStart, bStart){
  const aset = new Set(trigramCells(aStart));
  let c=0;
  for(const i of trigramCells(bStart)) if(aset.has(i)) c++;
  return c;
}
function overlapMatchIdx(aStart, bStart){
  const aset = new Set(trigramCells(aStart));
  for(const i of trigramCells(bStart)) if(aset.has(i)) return i;
  return null;
}
function trigramAtIndex(idx){
  for(const group of ['w1','w2']){
    const pl = state.placed[group];
    if(!pl) continue;
    if(idx >= pl.start && idx < pl.start + TR){
      return {group, start: pl.start, tri: pl.tri, offset: idx - pl.start};
    }
  }
  return null;
}
function singleAt(idx){
  return state.singles.find(s => s.idx === idx) || null;
}
function cellChar(idx){
  const t = trigramAtIndex(idx);
  if(t) return t.tri[t.offset];
  const s = singleAt(idx);
  if(s) return s.ch;
  return "";
}
function removeSinglesInCells(cells){
  const set = new Set(cells);
  state.singles = state.singles.filter(s => !set.has(s.idx));
}
function deleteTrigramGroup(group){
  if(!state.placed[group]) return false;
  const start = state.placed[group].start;
  state.placed[group] = null;
  state.focusIdx = clamp(start, 0, getN()-1);
  return true;
}
function deleteAtIndex(idx){
  const t = trigramAtIndex(idx);
  if(t) return deleteTrigramGroup(t.group);
  const s = singleAt(idx);
  if(s){
    state.singles = state.singles.filter(x => x.idx !== idx);
    state.focusIdx = clamp(idx, 0, getN()-1);
    return true;
  }
  return false;
}
function focusCell(idx){
  const n = getN();
  const i = clamp(idx, 0, n-1);
  state.focusIdx = i;
  if(state.useCustomKB) return;
  const inp = el.grid.querySelector(`input[data-idx="${i}"]`);
  if(inp){
    inp.focus({preventScroll:true});
    try{
      const len = inp.value ? inp.value.length : 0;
      inp.setSelectionRange(len, len);
    }catch{}
  }
}

/* =======================
   Always-active typing
   ======================= */
function nextEditableFrom(startIdx, dir){
  const n = getN();
  let i = clamp(startIdx, 0, n-1);
  while(i >= 0 && i < n){
    if(!trigramAtIndex(i)) return i;
    i += dir;
  }
  return null;
}
function typeLetterAtIndex(idx, ch){
  const n = getN();
  const lower = ch.toLowerCase();
  state.singles = state.singles.filter(x => x.idx !== idx);
  state.singles.push({id: uid(), ch: lower, idx});
  const next = nextEditableFrom(idx + 1, +1);
  state.focusIdx = (next == null) ? clamp(idx + 1, 0, n-1) : next;
}
function typeLetterIntoGrid(letter){
  if(state.finished) return false;
  if(state.modalOpen) return false;

  const ch = String(letter || "").slice(0,1);
  if(!isAlpha(ch)) return false;

  clearTransientOnAnyChange();

  const n = getN();
  let idx = clamp(state.focusIdx ?? 0, 0, n-1);
  if(trigramAtIndex(idx)){
    const found = nextEditableFrom(idx, +1);
    if(found == null) return false;
    idx = found;
  }

  typeLetterAtIndex(idx, ch);
  renderSmart();
  return true;
}

/* =======================
   Keyboard detection / build
   ======================= */
function shouldUseCustomKB(){
  const coarse = window.matchMedia && window.matchMedia('(pointer:coarse)').matches;
  const small = window.matchMedia && window.matchMedia('(max-width: 920px)').matches;
  return !!(coarse && small);
}
function setCustomKBEnabled(on){
  state.useCustomKB = !!on;
  document.documentElement.classList.toggle('has-kb', state.useCustomKB);
  buildKeyboard();
  requestAnimationFrame(()=> updateKeyboardHeightVar());
}
function updateKeyboardHeightVar(){
  if(!state.useCustomKB) return;
  const rect = el.kbHost.getBoundingClientRect();
  if(rect && rect.height){
    document.documentElement.style.setProperty('--kb-h', `${Math.ceil(rect.height)}px`);
  }
}
function pressKeyAction(kind, val){
  if(state.finished) return;
  if(state.modalOpen) return;
  if(kind === 'letter'){
    typeLetterIntoGrid(val);
  }else if(kind === 'delete'){
    kbBackspace();
  }else if(kind === 'enter'){
    if(!canEnableCheckNow()) return;
    onCheck();
  }
}
function makeKey(label, aria, cls, kind, val){
  const b = document.createElement('button');
  b.type = "button";
  b.className = `kbKey ${cls||""}`.trim();
  b.setAttribute('aria-label', aria || label);
  if(kind === 'letter') b.textContent = label;
  else if(kind === 'enter') b.textContent = "CHECK";
  else b.textContent = "DEL";

  b.addEventListener('pointerdown', (e)=>{
    e.preventDefault();
    e.stopPropagation();
    if(b.classList.contains('is-disabled')) return;
    pressKeyAction(kind, val);
  }, {passive:false});
  return b;
}
function buildKeyboard(){
  el.kbHost.innerHTML = "";
  if(!state.useCustomKB) return;

  const kb = document.createElement('div');
  kb.className = "kb";

  const rows = ["QWERTYUIOP","ASDFGHJKL"];
  rows.forEach((row)=>{
    const r = document.createElement('div');
    r.className = "kbRow";
    for(const ch of row){
      r.appendChild(makeKey(ch, `Letter ${ch}`, "", "letter", ch.toLowerCase()));
    }
    kb.appendChild(r);
  });

  const r3 = document.createElement('div');
  r3.className = "kbRow";
  r3.appendChild(makeKey("CHECK", "Check", "wide enter", "enter", null));
  for(const ch of "ZXCVBNM"){
    r3.appendChild(makeKey(ch, `Letter ${ch}`, "", "letter", ch.toLowerCase()));
  }
  r3.appendChild(makeKey("DEL", "Delete", "wide delete", "delete", null));
  kb.appendChild(r3);

  el.kbHost.appendChild(kb);
  requestAnimationFrame(()=> {
    updateKeyboardHeightVar();
    updateKeyboardState();
  });
}
function updateKeyboardState(){
  if(!state.useCustomKB) return;
  const enter = el.kbHost.querySelector('.kbKey.enter');
  if(enter){
    const ok = canEnableCheckNow() && !state.finished && !state.modalOpen;
    enter.classList.toggle('is-disabled', !ok);
    enter.setAttribute('aria-disabled', ok ? 'false' : 'true');
  }
}

/* =======================
   Invalid / excluded detection (for red underlines + warnings)
   ======================= */
function compressMaximalStrings(arr){
  const uniq = Array.from(new Set(arr.filter(Boolean)));
  uniq.sort((a,b)=> b.length - a.length);
  const kept = [];
  for(const s of uniq){
    if(!kept.some(k => k.includes(s))) kept.push(s);
  }
  return kept;
}
function computeMax3Invalid(){
  const n = getN();
  const p = current();
  const w1 = norm(p.word1);
  const w2 = norm(p.word2);

  state.badSet = new Set();
  state.badTris = { w1: new Set(), w2: new Set() };
  const runsW1 = [];
  const runsW2 = [];

  const chars = Array.from({length:n}, (_,i)=>cellChar(i));
  let i=0;
  while(i<n){
    if(!chars[i]){ i++; continue; }
    let j=i;
    while(j<n && chars[j]) j++;
    const len = j - i;

    if(len >= 4){
      for(let a=i; a<j; a++){
        for(let b=a+4; b<=j; b++){
          const s = chars.slice(a,b).join("").toLowerCase();
          const inW1 = (w1 && w1.includes(s));
          const inW2 = (w2 && w2.includes(s));
          if(inW1 || inW2){
            for(let k=a;k<b;k++) state.badSet.add(k);
            for(let t=0; t<=s.length-TR; t++){
              const tri = s.slice(t,t+TR);
              if(inW1) state.badTris.w1.add(tri);
              if(inW2) state.badTris.w2.add(tri);
            }
            if(inW1) runsW1.push(s);
            if(inW2) runsW2.push(s);
          }
        }
      }
    }
    i = j;
  }

  state.badRuns.w1 = compressMaximalStrings(runsW1);
  state.badRuns.w2 = compressMaximalStrings(runsW2);
}
function computeTwoTrigramsInvalid(){
  const n = getN();
  const p = current();
  const w1 = norm(p.word1);
  const w2 = norm(p.word2);

  state.twoSet = new Set();
  state.twoTris = { w1: new Set(), w2: new Set() };

  const chars = Array.from({length:n}, (_,i)=>cellChar(i));
  const occ = { w1: [], w2: [] };

  for(let s=0; s<=n-TR; s++){
    if(!chars[s] || !chars[s+1] || !chars[s+2]) continue;
    const tri = (chars[s] + chars[s+1] + chars[s+2]).toLowerCase();
    if(w1 && w1.includes(tri)) occ.w1.push({start:s, tri});
    if(w2 && w2.includes(tri)) occ.w2.push({start:s, tri});
  }

  for(const group of ['w1','w2']){
    if(occ[group].length >= 2){
      for(const o of occ[group]){
        state.twoTris[group].add(o.tri);
        for(const k of trigramCells(o.start)) state.twoSet.add(k);
      }
    }
  }
}
function computeHintExcludedTrigrams(){
  state.exclSet = new Set();
  state.exclTris = { w1: new Set(), w2: new Set() };

  const n = getN();
  const p = current();
  const chars = Array.from({length:n}, (_,i)=>cellChar(i));

  function scan(group, word, locked){
    const w = norm(word);
    if(!w) return;
    for(let s=0; s<=n-TR; s++){
      if(!chars[s] || !chars[s+1] || !chars[s+2]) continue;
      const tri = (chars[s]+chars[s+1]+chars[s+2]).toLowerCase();
      if(locked && tri === locked) continue;
      if(w.includes(tri)){
        state.exclTris[group].add(tri);
        state.exclSet.add(s); state.exclSet.add(s+1); state.exclSet.add(s+2);
      }
    }
  }

  if(state.hintsUsed.w1) scan('w1', p.word1, norm(p.tri1));
  if(state.hintsUsed.w2) scan('w2', p.word2, norm(p.tri2));
}

/* =======================
   Overlap helpers
   ======================= */
function overlapIsValid(aStart, aTri, bStart, bTri){
  const ol = overlapCount(aStart, bStart);
  if(ol === 0) return true;
  if(ol !== 1) return false;
  const common = overlapMatchIdx(aStart, bStart);
  const aCh = aTri[common - aStart];
  const bCh = bTri[common - bStart];
  return aCh === bCh;
}
function overlapActiveNow(){
  const a = state.placed.w1, b = state.placed.w2;
  if(!a || !b) return false;
  if(overlapCount(a.start, b.start) !== 1) return false;
  return overlapIsValid(a.start, a.tri, b.start, b.tri);
}
function computeOverlapIdxSet(){
  const a = state.placed.w1, b = state.placed.w2;
  const set = new Set();
  if(!a || !b) return set;
  if(overlapCount(a.start, b.start) !== 1) return set;
  const common = overlapMatchIdx(a.start, b.start);
  if(common == null) return set;
  const aCh = a.tri[common - a.start];
  const bCh = b.tri[common - b.start];
  if(aCh === bCh) set.add(common);
  return set;
}

/* =======================
   Status messages (NOW ALWAYS ENABLED)
   ======================= */
function updateStatusMessages(){
  if(state.finished) return;
  if(state.lockMsg) return;

  const hasMax3 = state.badSet && state.badSet.size > 0;
  const hasTwo  = state.twoSet && state.twoSet.size > 0;
  const hasExcluded = state.exclSet && state.exclSet.size > 0;
  const hasOverlap = overlapActiveNow();

  if(hasMax3){ setMsg("Max 3 contiguous letters allowed", 'warn'); state.overlapMsgOn=false; return; }
  if(hasTwo){  setMsg(TWOTRI_TEXT, 'warn'); state.overlapMsgOn=false; return; }
  if(hasExcluded){ setMsg(excludedMsgText(), 'warn'); state.overlapMsgOn=false; return; }

  if(el.msg.classList.contains('warn') && !state.msgTransient) setMsg("");
  if(state.msgTransient) return;

  if(hasOverlap){
    if(el.msg.textContent !== OVERLAP_TEXT || el.msg.classList.contains('warn')) setMsg(OVERLAP_TEXT);
    state.overlapMsgOn = true;
  }else{
    if(state.overlapMsgOn && el.msg.textContent === OVERLAP_TEXT) setMsg("");
    state.overlapMsgOn = false;
  }
}

/* =======================
   Hints: extra letters
   ======================= */
function computeHint3Letters(){
  const n = getN();
  const p = current();
  const ans = norm(p.answer);
  const covered = new Set();
  // best-effort: derive positions from answer
  p.tri1 = norm(p.tri1 || "");
  p.tri2 = norm(p.tri2 || "");
  const t1 = (p.tri1 && ans.includes(p.tri1)) ? ans.indexOf(p.tri1) : 0;
  let t2 = (p.tri2 && ans.includes(p.tri2)) ? ans.indexOf(p.tri2) : 0;
  if(p.tri1 && p.tri2 && t2 === t1){
    const second = ans.indexOf(p.tri2, t1 + 1);
    if(second !== -1) t2 = second;
  }

  const a1 = clamp(t1, 0, n-TR);
  const a2 = clamp(t2, 0, n-TR);

  for(let k=0;k<TR;k++) covered.add(a1 + k);
  for(let k=0;k<TR;k++) covered.add(a2 + k);

  const leftover = [];
  for(let i=0;i<n;i++) if(!covered.has(i)) leftover.push(ans[i]);
  leftover.sort();
  return leftover;
}
function rebuildBank(){
  state.bank = computeHint3Letters().map(ch => ({id: uid(), ch}));
}

/* =======================
   Hints: placing/cycling (assist only)
   ======================= */
function placeTrigram(group, tri){
  if(!flags().allowClueTapPlace && !flags().allowHintTapPlace) return;
  if(state.finished) return;
  clearTransientOnAnyChange();

  const n = getN();
  const t = norm(tri);
  if(!t || t.length !== TR) return;

  const otherGroup = group === 'w1' ? 'w2' : 'w1';
  const other = state.placed[otherGroup];

  let start = (state.placed[group] ? state.placed[group].start : null);
  const focus = clamp(state.focusIdx ?? 0, 0, n-1);
  const prefStart = clamp(focus, 0, startMax());

  function tryStartsInOrder(){
    const order = [];
    order.push(prefStart);
    for(let d=1; d<=startMax(); d++){
      if(prefStart-d >= 0) order.push(prefStart-d);
      if(prefStart+d <= startMax()) order.push(prefStart+d);
    }
    return order;
  }

  if(start == null){
    start = null;
    for(const s of tryStartsInOrder()){
      if(other){
        const ol = overlapCount(s, other.start);
        if(ol > 1) continue;
        if(ol === 1 && !overlapIsValid(s, t, other.start, other.tri)) continue;
      }
      start = s; break;
    }
    if(start == null){
      setTransientMsg("can’t place", 1800);
      return;
    }
  }

  state.placed[group] = {start, tri:t};
  removeSinglesInCells(trigramCells(start));
}

/* =======================
   Underline inputs (red always, yellow/blue only if trigram exists in grid)
   ======================= */
function errorItemsForGroup(group){
  if(state.badRuns[group] && state.badRuns[group].length){
    return state.badRuns[group].map(s => ({sub:s, cls:"u-red"}));
  }
  if(state.twoTris[group] && state.twoTris[group].size){
    return Array.from(state.twoTris[group]).map(t => ({sub:t, cls:"u-red"}));
  }
  if(state.exclTris[group] && state.exclTris[group].size){
    return Array.from(state.exclTris[group]).map(t => ({sub:t, cls:"u-red"}));
  }
  return [];
}
function inferredSingleTrigram(group){
  const n = getN();
  const p = current();
  const w = norm(group === 'w1' ? p.word1 : p.word2);
  if(!w) return null;

  const found = [];
  for(let s=0; s<=n-TR; s++){
    const a = cellChar(s), b = cellChar(s+1), c = cellChar(s+2);
    if(!a || !b || !c) continue;
    const tri = (a+b+c).toLowerCase();
    if(w.includes(tri)) found.push(tri);
  }

  const uniq = [];
  const seen = new Set();
  for(const t of found){
    if(seen.has(t)) continue;
    seen.add(t);
    uniq.push(t);
  }
  return (uniq.length === 1) ? uniq[0] : null;
}
function triForClue(group){
  const pl = state.placed[group];
  if(pl && pl.tri) return pl.tri;
  return inferredSingleTrigram(group);
}

/* =======================
   Check logic
   ======================= */
function canEnableCheckNow(){
  const n = getN();
  for(let i=0;i<n;i++) if(!cellChar(i)) return false;
  return true;
}
function countTrigramsInWord(attempt, word){
  const n = attempt.length;
  const w = norm(word);
  const found = [];
  if(!w) return found;
  for(let s=0; s<=n-TR; s++){
    const tri = attempt.slice(s, s+TR);
    if(w.includes(tri)) found.push(tri);
  }
  return found;
}
function hintPhraseText(h){
  if(h === 0) return "with no hints";
  if(h === 1) return "with 1 hint";
  return `with ${h} hints`;
}
function onCheck(){
  if(state.finished) return;
  if(state.modalOpen) return;
  clearTransientOnAnyChange();

  const n = getN();
  if(!canEnableCheckNow()){
    setTransientMsg(`Fill all ${n}`);
    return;
  }

  computeMax3Invalid();
  computeTwoTrigramsInvalid();
  computeHintExcludedTrigrams();

  const attempt = Array.from({length:n}, (_,i)=>cellChar(i)).join("").toLowerCase();
  const p = current();
  const ans = norm(p.answer);

  if(attempt === ans){
    setMsg(`Correct — ${hintPhraseText(state.hintCount)}!`, 'result');
    state.finished = true;
    state.showedAnswer = false;
    renderSmart();
    return;
  }

  shakeGrid();

  if(flags().checkFeedback === "minimal"){
    setTransientMsg("Not quite", 1400);
    renderSmart();
    return;
  }

  if(state.badSet.size){ setMsg("Max 3 contiguous letters allowed", "warn"); renderSmart(); return; }
  if(state.twoSet.size){ setMsg(TWOTRI_TEXT, "warn"); renderSmart(); return; }
  if(state.exclSet.size){ setMsg(excludedMsgText(), "warn"); renderSmart(); return; }

  const w1Hits = countTrigramsInWord(attempt, p.word1);
  const w2Hits = countTrigramsInWord(attempt, p.word2);

  let msg = "";
  if(w1Hits.length === 0 && w2Hits.length === 0){
    msg = "You didn’t use any trigrams";
  }else if(w1Hits.length === 0){
    msg = "No trigram from word 1";
  }else if(w2Hits.length === 0){
    msg = "No trigram from word 2";
  }else if(w1Hits.length > 1 || w2Hits.length > 1){
    msg = TWOTRI_TEXT;
  }

  if(msg){
    state.lockMsg = true;
    setMsg(msg, "warn");
  }else{
    setMsg("");
  }

  renderSmart();
}

/* =======================
   Hint track UI (unchanged behaviour: clickable placement only after Quick controls)
   ======================= */
function makeTrigramBlock(tri, cls, labelText, onClickMaybe){
  const canClick = !!flags().allowHintTapPlace && typeof onClickMaybe === "function";

  const block = document.createElement('div');
  block.className = "trackBlock";

  const box = document.createElement('div');
  box.className = "letters " + (canClick ? "clickable" : "is-disabled");
  box.setAttribute("aria-label", labelText);

  if(canClick){
    box.setAttribute("role","button");
    box.addEventListener('click', onClickMaybe);
  }

  for(let i=0;i<tri.length;i++){
    const d = document.createElement('div');
    d.className = "letter " + cls;
    d.textContent = tri[i];
    box.appendChild(d);
  }
  block.appendChild(box);
  return block;
}
function renderHintTrack(){
  const p = current();
  el.trackW1.innerHTML = "";
  el.trackW2.innerHTML = "";
  el.trackExtras.innerHTML = "";

  el.trackW1.style.display = "none";
  el.trackW2.style.display = "none";
  el.trackExtras.style.display = "none";

  if(state.hintsUsed.w1){
    el.trackW1.appendChild(
      makeTrigramBlock(norm(p.tri1), "sel-w1", "word 1 trigram", ()=>{
        placeTrigram('w1', norm(p.tri1));
        renderSmart();
      })
    );
    el.trackW1.style.display = "";
  }

  if(state.hintsUsed.w2){
    el.trackW2.appendChild(
      makeTrigramBlock(norm(p.tri2), "sel-w2", "word 2 trigram", ()=>{
        placeTrigram('w2', norm(p.tri2));
        renderSmart();
      })
    );
    el.trackW2.style.display = "";
  }

  if(state.hintsUsed.extras){
    if(state.bank.length === 0) rebuildBank();

    const block = document.createElement('div');
    block.className = "trackBlock";

    const row = document.createElement('div');
    row.className = "extrasRow";

    for(const tile of state.bank){
      const box = document.createElement('div');
      const canInsert = !!flags().allowHint3TapInsert;
      box.className = "letters " + (canInsert ? "" : "is-disabled");

      const d = document.createElement('div');
      d.className = "letter extra";
      d.textContent = tile.ch;

      if(canInsert){
        d.addEventListener('click', ()=>{
          if(state.finished) return;
          if(state.modalOpen) return;
          clearTransientOnAnyChange();

          const n = getN();
          for(let i=0;i<n;i++){
            if(trigramAtIndex(i)) continue;
            if(state.singles.find(s=>s.idx===i)) continue;
            state.singles.push({id: uid(), ch: tile.ch, idx: i});
            state.focusIdx = clamp(i+1,0,n-1);
            renderSmart();
            return;
          }
          setTransientMsg("No blank spot", 2000);
        });
      }

      box.appendChild(d);
      row.appendChild(box);
    }

    block.appendChild(row);
    el.trackExtras.appendChild(block);
    el.trackExtras.style.display = "";
  }
}

/* =======================
   Grid render
   ======================= */
function renderGrid(stealFocus=true){
  const n = getN();
  const f = flags();

  // compute invalids EVERY render (needed for always-on messages)
  computeMax3Invalid();
  computeTwoTrigramsInvalid();
  computeHintExcludedTrigrams();

  const overlapSet = f.showGridColors ? computeOverlapIdxSet() : new Set();

  el.grid.style.setProperty('--n', String(n));
  el.grid.innerHTML = "";

  for(let i=0;i<n;i++){
    const cell = document.createElement('div');
    cell.className = "cell";
    cell.dataset.idx = String(i);

    if(!state.finished && i === clamp(state.focusIdx ?? 0, 0, n-1)){
      cell.classList.add('active');
    }

    const tri = trigramAtIndex(i);

    if(f.showGridColors && tri){
      if(overlapSet.has(i)) cell.classList.add('bg-ol');
      else cell.classList.add(tri.group==='w1' ? 'bg-w1' : 'bg-w2');
    }
    if(f.showBadCellColor && (state.badSet.has(i) || state.twoSet.has(i) || state.exclSet.has(i))){
      cell.classList.add('bg-bad');
    }

    if(f.allowDragTrigrams && tri){
      cell.classList.add('grabbable');
    }

    const input = document.createElement('input');
    input.type = "text";
    input.inputMode = "none";
    input.autocapitalize = "none";
    input.autocomplete = "off";
    input.autocorrect = "off";
    input.spellcheck = false;
    input.maxLength = 1;
    input.dataset.idx = String(i);
    input.value = cellChar(i);
    input.name = "x-"+i;
    input.enterKeyHint = "done";

    input.readOnly = state.finished || state.useCustomKB;
    input.tabIndex = state.useCustomKB ? -1 : 0;

    input.addEventListener('focus', ()=>{ state.focusIdx = i; });

    input.addEventListener('keydown', (e)=>{
      if(state.finished) return;
      if(state.modalOpen){ e.preventDefault(); return; }

      if(e.key === " " || e.code === "Space" || e.key === "Spacebar"){
        e.preventDefault(); e.stopPropagation();
        clearTransientOnAnyChange();
        focusCell(i + 1);
        renderSmart();
        return;
      }
      if(e.key === "ArrowLeft"){ e.preventDefault(); e.stopPropagation(); clearTransientOnAnyChange(); focusCell(i - 1); renderSmart(); return; }
      if(e.key === "ArrowRight"){ e.preventDefault(); e.stopPropagation(); clearTransientOnAnyChange(); focusCell(i + 1); renderSmart(); return; }

      if(e.key && e.key.length === 1 && isAlpha(e.key) && !input.readOnly){
        e.preventDefault();
        clearTransientOnAnyChange();
        typeLetterAtIndex(i, e.key);
        renderSmart();
        return;
      }

      if(e.key === "Backspace" || e.key === "Delete"){
        e.preventDefault();
        e.stopPropagation();
        clearTransientOnAnyChange();

        if(singleAt(i)){
          deleteAtIndex(i);
          renderSmart();
          return;
        }

        if(i === 0) return;

        if(deleteAtIndex(i - 1)){ renderSmart(); return; }
        focusCell(i - 1);
        renderSmart();
        return;
      }

      if(e.key === "Enter"){
        e.preventDefault();
        onCheck();
        return;
      }
    });

    if(!input.readOnly){
      input.addEventListener('input', ()=>{
        if(state.modalOpen) return;
        clearTransientOnAnyChange();
        const v = input.value || "";
        const ch = v.slice(-1);
        if(!ch){ renderSmart(); return; }
        if(!isAlpha(ch)){ input.value = cellChar(i); renderSmart(); return; }
        typeLetterAtIndex(i, ch);
        renderSmart();
      });
    }

    cell.addEventListener('pointerdown', (e)=>{
      if(state.finished) return;
      if(state.modalOpen) return;
      state.focusIdx = i;
      if(!state.useCustomKB){
        requestAnimationFrame(()=> focusCell(i));
      }
      renderSmart();
    });

    cell.appendChild(input);
    el.grid.appendChild(cell);
  }

  if(stealFocus && !state.finished && !state.useCustomKB && !state.modalOpen){
    requestAnimationFrame(()=> focusCell(state.focusIdx ?? 0));
  }
}

function render(stealFocus=true){
  const p = current();
  const n = getN();

  el.count.textContent = `${state.i+1}/${PUZZLES.length}`;
  el.wrap.classList.toggle('solved', state.finished);
  el.wrap.classList.toggle('no-assist', !state.assist);

  renderGrid(stealFocus);

  const [t1, t2] = splitClueTwoWords(p.clue);

  const err1 = errorItemsForGroup('w1');
  const err2 = errorItemsForGroup('w2');

  let a = escapeHtml(t1);
  let b = escapeHtml(t2);

  if(err1.length){
    a = underlineBySubstrings(t1, err1);
  }else{
    const tri1 = triForClue('w1');
    if(tri1) a = underlineBySubstrings(t1, [{sub:tri1, cls:"u-w1"}]);
  }

  if(err2.length){
    b = underlineBySubstrings(t2, err2);
  }else{
    const tri2 = triForClue('w2');
    if(tri2) b = underlineBySubstrings(t2, [{sub:tri2, cls:"u-w2"}]);
  }

  el.clue.innerHTML =
    `<span class="clueWord" data-group="w1">${a}</span> ` +
    `<span class="clueWord" data-group="w2">${b}</span>` +
    `<span class="len">(${n})</span>`;

  renderHintTrack();

  el.checkBtn.classList.toggle('ready', canEnableCheckNow());
  el.checkBtn.disabled = state.finished;

  // NEW: Hints button copy
  const anyLeft = hasAnyHintLeft();
  el.hintBtn.textContent = anyLeft ? "Hints" : "GIVE UP";
  el.hintBtn.disabled = state.finished;

  updateStatusMessages();
  updateKeyboardState();
}

/* =======================
   Modal sizing (fixed frame)
   ======================= */
function modalCardEl(){
  return el.hintModal.querySelector('.modalCard');
}
function lockModalCardHeight(){
  const card = modalCardEl();
  if(!card) return;
  const maxH = Math.max(240, Math.floor(window.innerHeight - 28));
  const h = Math.ceil(card.getBoundingClientRect().height);
  if(state.modalView === 'list'){
    state.modalFixedH = Math.min(h, maxH);
  }
  const use = (state.modalFixedH != null) ? Math.min(state.modalFixedH, maxH) : Math.min(h, maxH);
  card.style.height = `${use}px`;
}
function unlockModalCardHeight(){
  const card = modalCardEl();
  if(card) card.style.height = "";
  state.modalFixedH = null;
}

/* =======================
   Hint modal: list + detail + SELECT/DETAILS
   ======================= */
function openHintModal(view='list', hintId=null){
  if(state.finished) return;
  state.modalOpen = true;
  state.modalView = view;
  state.modalHintId = hintId;

  el.hintModal.classList.add('open');
  el.hintModal.setAttribute('aria-hidden', 'false');

  renderHintModal();

  requestAnimationFrame(()=>{
    lockModalCardHeight();
    try{ el.hintModalClose.focus({preventScroll:true}); }catch{}
  });
}
function closeHintModal(){
  if(!state.modalOpen) return;
  state.modalOpen = false;
  state.modalView = 'list';
  state.modalHintId = null;

  el.hintModal.classList.remove('open');
  el.hintModal.setAttribute('aria-hidden', 'true');

  unlockModalCardHeight();

  requestAnimationFrame(()=>{
    if(!state.useCustomKB && !state.finished) focusCell(state.focusIdx ?? 0);
  });
}

function extrasUnlocked(){
  return state.hintsUsed.w1 && state.hintsUsed.w2;
}
function hasAnyHintLeft(){
  return (!state.hintsUsed.quick) || (!state.hintsUsed.w1) || (!state.hintsUsed.w2) || (!state.hintsUsed.extras);
}
function canSelectHint(id){
  if(state.hintsUsed[id]) return false;
  if(id === HINT_IDS.extras) return extrasUnlocked();
  return true;
}
function hintStatus(id){
  if(state.hintsUsed[id]) return "used";
  if(id === HINT_IDS.extras && !extrasUnlocked()) return "locked";
  return "";
}

function applyHint(id){
  if(!canSelectHint(id)) return;

  if(id === HINT_IDS.quick){
    state.hintsUsed.quick = true;
    state.hintCount += 1;
    state.assist = true;
  }else if(id === HINT_IDS.w1){
    state.hintsUsed.w1 = true;
    state.hintCount += 1;
  }else if(id === HINT_IDS.w2){
    state.hintsUsed.w2 = true;
    state.hintCount += 1;
  }else if(id === HINT_IDS.extras){
    state.hintsUsed.extras = true;
    state.hintCount += 1;
    if(state.bank.length === 0) rebuildBank();
  }

  clearTransientOnAnyChange();
  renderSmart();
  closeHintModal();
}

function makeBadge(status){
  if(status === "used"){
    const b = document.createElement('div');
    b.className = "badge";
    b.innerHTML = `<span aria-hidden="true">✓</span><span>USED</span>`;
    return b;
  }
  if(status === "locked"){
    const b = document.createElement('div');
    b.className = "badge";
    b.textContent = "LOCKED";
    return b;
  }
  return null;
}

function makeHintRow({id, title, sub, cls}){
  const row = document.createElement('div');
  row.className = `hintOptRow ${cls||""}`.trim();

  const main = document.createElement('div');
  main.className = "hintOptMain";

  const t = document.createElement('div');
  t.className = "hintOptTitle";
  t.textContent = title;
  main.appendChild(t);

  if(sub){
    const s = document.createElement('div');
    s.className = "hintOptSub";
    s.textContent = sub;
    main.appendChild(s);
  }

  const right = document.createElement('div');
  right.className = "hintOptRight";

  const status = hintStatus(id);
  const badge = makeBadge(status);
  if(badge) right.appendChild(badge);

  const btns = document.createElement('div');
  btns.className = "optBtns";

  const details = document.createElement('button');
  details.type = "button";
  details.className = "optBtn";
  details.textContent = "DETAILS";
  details.addEventListener('pointerdown', (e)=>{ e.preventDefault(); e.stopPropagation(); }, {passive:false});
  details.addEventListener('click', (e)=>{
    e.preventDefault(); e.stopPropagation();
    state.modalView = 'detail';
    state.modalHintId = id;
    renderHintModal();
    requestAnimationFrame(lockModalCardHeight);
  });

  const select = document.createElement('button');
  select.type = "button";
  select.className = "optBtn";
  select.textContent = "SELECT";
  const selectable = canSelectHint(id);
  select.disabled = !selectable;
  select.addEventListener('pointerdown', (e)=>{ e.preventDefault(); e.stopPropagation(); }, {passive:false});
  select.addEventListener('click', (e)=>{
    e.preventDefault(); e.stopPropagation();
    applyHint(id);
  });

  btns.appendChild(details);
  btns.appendChild(select);

  right.appendChild(btns);

  row.appendChild(main);
  row.appendChild(right);

  return row;
}

function renderHintDetail(id){
  const p = current();
  const wrap = document.createElement('div');

  const title = document.createElement('div');
  title.style.fontWeight = "950";
  title.style.fontSize = "16px";
  title.style.marginBottom = "8px";
  title.textContent = hintLabel(id);
  wrap.appendChild(title);

  if(id === HINT_IDS.quick){
    const box = document.createElement('div');
    box.className = "qcHelp";
    box.innerHTML = `
      <ul>
        <li><b>Tap a clue word</b> to place a trigram in the grid</li>
        <li><b>Tap again</b> to cycle to the next trigram</li>
        <li><b>Drag trigram blocks</b> around the grid</li>
        <li><b>Colours</b> show trigrams, overlap and errors</li>
        <li>Hints become tappable to place (trigrams / extra letters)</li>
      </ul>
      <div class="note">You can still play without Quick controls by typing letters normally.</div>
    `;
    wrap.appendChild(box);
  }

  if(id === HINT_IDS.w1){
    const txt = document.createElement('div');
    txt.style.fontSize = "15px";
    txt.style.lineHeight = "1.35";
    txt.textContent = "Reveals the correct trigram from clue word 1.";
    wrap.appendChild(txt);

    const tiles = document.createElement('div');
    tiles.className = "hintTilesInline";
    const tri = norm(p.tri1);
    const box = document.createElement('div');
    box.className = "letters is-disabled";
    for(const ch of tri){
      const d = document.createElement('div');
      d.className = "letter sel-w1";
      d.textContent = ch;
      box.appendChild(d);
    }
    tiles.appendChild(box);
    wrap.appendChild(tiles);
  }

  if(id === HINT_IDS.w2){
    const txt = document.createElement('div');
    txt.style.fontSize = "15px";
    txt.style.lineHeight = "1.35";
    txt.textContent = "Reveals the correct trigram from clue word 2.";
    wrap.appendChild(txt);

    const tiles = document.createElement('div');
    tiles.className = "hintTilesInline";
    const tri = norm(p.tri2);
    const box = document.createElement('div');
    box.className = "letters is-disabled";
    for(const ch of tri){
      const d = document.createElement('div');
      d.className = "letter sel-w2";
      d.textContent = ch;
      box.appendChild(d);
    }
    tiles.appendChild(box);
    wrap.appendChild(tiles);
  }

  if(id === HINT_IDS.extras){
    const txt = document.createElement('div');
    txt.style.fontSize = "15px";
    txt.style.lineHeight = "1.35";
    txt.textContent = "Shows the remaining letters (not part of the two trigrams).";
    wrap.appendChild(txt);

    const tiles = document.createElement('div');
    tiles.className = "hintTilesInline";

    const letters = computeHint3Letters();
    const row = document.createElement('div');
    row.className = "letters is-disabled";
    for(const ch of letters){
      const d = document.createElement('div');
      d.className = "letter extra";
      d.textContent = ch;
      row.appendChild(d);
    }
    tiles.appendChild(row);
    wrap.appendChild(tiles);

    const note = document.createElement('div');
    note.style.marginTop = "10px";
    note.style.fontSize = "13px";
    note.style.opacity = ".75";
    note.textContent = "Locked until both trigram hints have been selected.";
    wrap.appendChild(note);
  }

  const footer = document.createElement('div');
  footer.className = "detailFooter";

  const back = document.createElement('button');
  back.type = "button";
  back.className = "detailBtn";
  back.textContent = "GO BACK";
  back.addEventListener('click', (e)=>{
    e.preventDefault();
    state.modalView = 'list';
    state.modalHintId = null;
    renderHintModal();
    requestAnimationFrame(lockModalCardHeight);
  });

  const select = document.createElement('button');
  select.type = "button";
  select.className = "detailBtn primary";
  select.textContent = "SELECT";
  select.disabled = !canSelectHint(id);
  select.addEventListener('click', (e)=>{
    e.preventDefault();
    applyHint(id);
  });

  footer.appendChild(back);
  footer.appendChild(select);
  wrap.appendChild(footer);

  return wrap;
}

function renderHintModal(){
  el.hintModalBody.innerHTML = "";

  if(state.modalView === 'detail' && state.modalHintId){
    el.hintModalTitle.textContent = hintLabel(state.modalHintId);
    el.hintModalBody.appendChild(renderHintDetail(state.modalHintId));
    requestAnimationFrame(lockModalCardHeight);
    return;
  }

  el.hintModalTitle.textContent = "Hints";

  const list = document.createElement('div');
  list.appendChild(makeHintRow({
    id: HINT_IDS.quick,
    title: "Quick controls",
    sub: "Add, move and cycle trigrams without typing",
    cls: "opt-quick"
  }));
  list.appendChild(makeHintRow({ id: HINT_IDS.w1, title: "Word 1 trigram", sub: null, cls: "opt-w1" }));
  list.appendChild(makeHintRow({ id: HINT_IDS.w2, title: "Word 2 trigram", sub: null, cls: "opt-w2" }));
  list.appendChild(makeHintRow({ id: HINT_IDS.extras, title: "Extra letters", sub: null, cls: "opt-extras" }));

  el.hintModalBody.appendChild(list);
  requestAnimationFrame(lockModalCardHeight);
}

/* modal events */
el.hintModalClose.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); closeHintModal(); });
el.hintModal.addEventListener('pointerdown', (e)=>{
  if(e.target === el.hintModal){
    e.preventDefault();
    e.stopPropagation();
    closeHintModal();
  }
}, {passive:false});

/* Esc closes modal */
document.addEventListener('keydown', (e)=>{
  if(!state.modalOpen) return;
  if(e.key === "Escape"){
    e.preventDefault();
    closeHintModal();
  }else{
    if(e.key && e.key.length === 1) e.preventDefault();
    if(e.key === "Backspace" || e.key === "Delete" || e.key === "Enter") e.preventDefault();
  }
}, {capture:true});

/* =======================
   Hints button + GIVE UP
   ======================= */
function showAnswerNow(){
  if(state.finished) return;
  clearTransientOnAnyChange();

  const n = getN();
  const ans = norm(current().answer);

  state.placed = {w1:null, w2:null};
  state.singles = [];
  for(let i=0;i<n;i++) state.singles.push({id:uid(), ch: ans[i], idx:i});

  state.finished = true;
  state.showedAnswer = true;

  setMsg(`Answer: ${ans}`, "result");
  renderSmart();
}

function onHintsButton(){
  if(state.finished) return;
  if(state.modalOpen) return;

  if(!hasAnyHintLeft()){
    // NEW: "GIVE UP" reveals answer
    showAnswerNow();
    return;
  }
  openHintModal('list', null);
}

function bindFastTap(btn, fn){
  let last = 0;
  const run = (e)=>{
    const now = Date.now();
    if(e){
      e.preventDefault();
      e.stopPropagation();
    }
    if(now - last < 250) return;
    last = now;
    fn();
  };
  btn.addEventListener('pointerdown', run, {passive:false});
  btn.addEventListener('click', (e)=>{
    if(Date.now() - last < 400){ e.preventDefault(); return; }
    run(e);
  });
}

bindFastTap(el.hintBtn, onHintsButton);
bindFastTap(el.checkBtn, onCheck);

/* =======================
   Nav
   ======================= */
el.prevBtn.addEventListener('click', (e)=>{
  e.preventDefault();
  clearTransientOnAnyChange();
  closeHintModal();
  state.i=(state.i-1+PUZZLES.length)%PUZZLES.length;
  resetAllForPuzzle();
  renderSmart();
});
el.nextBtn.addEventListener('click', (e)=>{
  e.preventDefault();
  clearTransientOnAnyChange();
  closeHintModal();
  state.i=(state.i+1)%PUZZLES.length;
  resetAllForPuzzle();
  renderSmart();
});

/* =======================
   Clue tap (assist only)
   ======================= */
function firstTrigramOfWord(group){
  const p = current();
  const w = norm(group === 'w1' ? p.word1 : p.word2);
  if(w.length < TR) return null;
  return w.slice(0, TR);
}
function cyclePlacedTrigram(group){
  if(!flags().allowClueTapCycle) return;
  if(state.finished) return;

  const pl = state.placed[group];
  if(!pl) return;

  const p = current();
  const w = norm(group === 'w1' ? p.word1 : p.word2);
  const maxStart = Math.max(0, w.length - TR);
  if(maxStart === 0) return;

  let s = (group === 'w1' ? state.sel1 : state.sel2);
  if(s == null) s = 0;
  s = (s + 1) % (maxStart + 1);
  if(group === 'w1') state.sel1 = s; else state.sel2 = s;

  const tri = w.slice(s, s+TR);
  placeTrigram(group, tri);
}
function onClueWordActivate(group){
  if(state.finished) return;
  if(state.modalOpen) return;
  const f = flags();
  if(!f.allowClueTapPlace && !f.allowClueTapCycle) return;

  clearTransientOnAnyChange();

  if(state.placed[group]){
    cyclePlacedTrigram(group);
  }else{
    // if their trigram hint was selected, start with the correct one
    let tri = null;
    if(group === 'w1' && state.hintsUsed.w1) tri = norm(current().tri1);
    if(group === 'w2' && state.hintsUsed.w2) tri = norm(current().tri2);
    if(!tri) tri = firstTrigramOfWord(group);
    if(tri) placeTrigram(group, tri);
  }
  renderSmart();
}
(function bindClueFastTap(){
  let last = 0;
  el.clue.addEventListener('pointerdown', (e)=>{
    if(state.finished || state.modalOpen) return;
    const f = flags();
    if(!f.allowClueTapPlace && !f.allowClueTapCycle) return;

    const w = e.target && e.target.closest ? e.target.closest('.clueWord') : null;
    if(!w) return;
    e.preventDefault();
    e.stopPropagation();
    const now = Date.now();
    if(now - last < 250) return;
    last = now;
    onClueWordActivate(w.dataset.group);
  }, { passive:false });

  el.clue.addEventListener('click', (e)=>{
    if(state.modalOpen) return;
    const f = flags();
    if(!f.allowClueTapPlace && !f.allowClueTapCycle) return;

    const now = Date.now();
    if(now - last < 400){ e.preventDefault(); return; }
    const w = e.target && e.target.closest ? e.target.closest('.clueWord') : null;
    if(!w) return;
    e.preventDefault();
    onClueWordActivate(w.dataset.group);
  });
})();

/* Always-active typing outside grid */
document.addEventListener('keydown', (e)=>{
  if(state.finished) return;
  if(state.modalOpen) return;

  const target = e.target;
  const inGrid = target && target.closest && target.closest('#gridWrap');

  if(!inGrid && e.key && e.key.length === 1 && isAlpha(e.key)){
    const isOtherTyping = target && target.tagName === "INPUT";
    if(!isOtherTyping){
      e.preventDefault();
      typeLetterIntoGrid(e.key);
      return;
    }
  }
});

/* Backspace for custom KB */
function kbBackspace(){
  if(state.finished) return;
  if(state.modalOpen) return;
  clearTransientOnAnyChange();

  const n = getN();
  const idx = clamp(state.focusIdx ?? 0, 0, n-1);

  if(singleAt(idx)){
    deleteAtIndex(idx);
    renderSmart();
    return;
  }

  if(idx === 0) return;

  if(deleteAtIndex(idx - 1)){
    renderSmart();
    return;
  }
  state.focusIdx = clamp(idx - 1, 0, n-1);
  renderSmart();
}

/* Resize */
window.addEventListener('resize', ()=>{
  const next = shouldUseCustomKB();
  if(next !== state.useCustomKB) setCustomKBEnabled(next);
  updateKeyboardHeightVar();
  updateKeyboardState();
  if(state.modalOpen) requestAnimationFrame(lockModalCardHeight);
});

/* =======================
   Resets + init
   ======================= */
function resetMainGridOnly(){
  state.placed = {w1:null, w2:null};
  state.singles = [];
  state.focusIdx = 0;
  state.sel1 = null;
  state.sel2 = null;
  setMsg("");
  state.overlapMsgOn = false;
  state.lockMsg = false;
}
function resetAllForPuzzle(){
  state.finished = false;
  state.showedAnswer = false;

  state.hintCount = 0;
  state.hintsUsed = { quick:false, w1:false, w2:false, extras:false };
  state.assist = false;

  state.bank = [];
  resetMainGridOnly();
}

/* init */
setCustomKBEnabled(shouldUseCustomKB());
resetAllForPuzzle();
renderSmart();
</script>
</body>
</html>
