<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Trigram Demo</title>

<style>
  :root{
    --bg:#a9cdf3;
    --bubble:#fff;
    --ink:#0b0b0b;

    --w1:#fff3b3;   /* yellow */
    --w2:#cfe8ff;   /* blue */
    --ol:#c9f3d6;   /* green overlap */
    --bad:#ffc9d2;  /* red/pink warning */
    --submit:#F4D2FD;

    --kb-h: 260px;
    --caret: rgba(0,0,0,.18);

    /* spacing controls (we’ll tweak these next) */
    --clue-hint-gap: 7px;
    --lift-msg: 38px;
    --lift-hints: 96px;
    --msg-drop: 35px;        /* grid → warning msg down */
    --result-drop: 32px;     /* grid → result msg down (total, not extra) */
    --badge-drop: 72px;      /* result msg → badge down */
  }

  *{ box-sizing:border-box; }
  html, body{
    height:100%;
    overflow:hidden;
    overscroll-behavior:none;
    background:var(--bg);
  }
  body{
    margin:0;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
    color:var(--ink);
    text-align:center;
    -webkit-text-size-adjust:100%;
  }

  /* prevent selection / tap highlight inside the app */
  :is(.wrap,#wrap,#rotateOverlay,#hintsModal),
  :is(.wrap,#wrap,#rotateOverlay,#hintsModal) *{
    -webkit-user-select:none;
    user-select:none;
    -webkit-touch-callout:none;
    -webkit-tap-highlight-color: transparent;
    touch-action: manipulation;
  }

  /* ===== Layout ===== */
  :is(.wrap, #wrap){
    height:100dvh;
    max-height:100dvh;
    width:100%;
    max-width:980px;
    margin:0 auto;
    padding:12px 14px 14px;
    display:flex;
    flex-direction:column;
    align-items:stretch;
    justify-content:flex-start;
    overflow:hidden;
    position:relative;
  }

  .toprow{
    display:flex;
    justify-content:center;
    align-items:center;
    margin-top:2px;
    flex:0 0 auto;
  }

  .modePill{
    position:absolute;
    top:10px;
    right:14px;
    padding:4px 9px;
    border-radius:999px;
    font-size:11px;
    letter-spacing:.12em;
    text-transform:uppercase;
    background:rgba(255,255,255,.34);
    border:1px solid rgba(0,0,0,.12);
    color:rgba(0,0,0,.68);
    font-weight:700;
    opacity:.85;
    pointer-events:none; /* purely informational – clue still toggles assist */
  }

   .statsBtn{
    position:absolute;
    left:14px;
    top:10px;
    width:28px;   
    height:28px;  
    border-radius:999px;
    padding:0;
    margin:0;
    background:rgba(255,255,255,.34);
    border:1px solid rgba(0,0,0,.12);
    display:flex;
    align-items:center;
    justify-content:center;
    cursor:pointer;
    appearance:none;
    -webkit-appearance:none;
    outline:none;         
    box-shadow:none;
  }
  .statsBtn:focus{
    outline:none;
    box-shadow:none;
  }
  .statsBtn:active{
    transform:translateY(1px);
  }
  .statsIcon{
    width:20px;   
    height:20px;
    opacity:0.55;
    display:block;
    pointer-events:none;
  }


  .nav{
    display:flex;
    align-items:center;
    gap:10px;
    font-weight:900;
  }
  .nav :is(a, button){
    color:var(--ink);
    text-decoration:none;
    font-weight:900;
    padding:5px 10px;
    border-radius:999px;
    background:rgba(255,255,255,.32);
    border:2px solid rgba(0,0,0,.16);
    cursor:pointer;
    appearance:none;
    -webkit-appearance:none;
    font:inherit;
  }
  .nav :is(a, button):active{ transform:translateY(1px); }
  .count{ font-weight:900; opacity:.7; min-width:58px; text-align:center; }

  /* ===== Clue + floating hint track ===== */
  .clue{
    display:block;
    width:fit-content;
    max-width:min(940px,94vw);
    margin: clamp(18px, 3.6vh, 36px) auto 0;
    padding:14px 13px 15px 20px;
    background:var(--bubble);
    border-radius:18px;
    box-shadow:0 2px 6px rgba(0,0,0,.08);
    font-size:clamp(30px,5.4vw,38px);
    line-height:1.12;
    letter-spacing:.12px;
    font-weight:400;
    flex:0 0 auto;
  }

  /* ===== Assist activation flash (clue glow) ===== */
  .clue.assist-glow{
    animation: assistClueGlow 3.2s ease-out both;
  }
  @keyframes assistClueGlow{
    0%{
      box-shadow:
        0 2px 6px rgba(0,0,0,.08),
        0 0 0 4px rgba(70,255,150,.95),   /* green ring */
        0 0 40px rgba(70,255,150,.75);    /* green glow */
    }
    55%{
      box-shadow:
        0 2px 6px rgba(0,0,0,.08),
        0 0 0 4px rgba(70,255,150,.72),
        0 0 54px rgba(70,255,150,.6);
    }
    100%{
      box-shadow:
        0 2px 6px rgba(0,0,0,.08),
        0 0 0 0 rgba(70,255,150,0),
        0 0 0 rgba(70,255,150,0);
    }
  }

  /* ===== Assist activation flash (message) ===== */
  .msg.assistFlash{
    /* runs without needing .show; it fades in then down+out */
    animation: assistMsgFlash 4.2s ease-in-out both;
  }
  @keyframes assistMsgFlash{
    0%   { opacity:0;   transform: translateX(-50%) translateY(-6px); }
    12%  { opacity:.92; transform: translateX(-50%) translateY(0px); }
    75%  { opacity:.92; transform: translateX(-50%) translateY(0px); }
    100% { opacity:0;   transform: translateX(-50%) translateY(10px); }
  }

  .clue .len{
    opacity:.55;
    display:inline-block;
    font-size:.92em;
    line-height:1;
    vertical-align:middle;
    position:relative;
    top:-0.1em;
    margin-left:8px;
  }

  .clueWrap{
    position:relative;
    flex:0 0 auto;
    padding-bottom:0; /* only add space when the track is actually on top */
  }
  .clueWrap.hasTopTrack{
    padding-bottom:15px; /* makes room for the floating (top) track */
  }

  .hintTrackTop{
    position:absolute;
    left:50%;
    top: calc(100% + var(--clue-hint-gap));
    transform: translateX(-50%);
    margin:0;
    min-height:0;
    z-index:30;
  }

  .clueWord{
    display:inline-block;
    cursor:pointer;
    font-kerning:none;
    font-variant-ligatures:none;
    font-feature-settings:"kern" 0, "liga" 0, "clig" 0;
  }

  .u-w1, .u-w2, .u-red{
    text-decoration: underline;
    text-decoration-thickness: 6px;
    text-underline-offset: 9px;
    pointer-events:none;
  }
  .u-w1{ text-decoration-color: rgba(255,220,0,.9); }
  .u-w2{ text-decoration-color: rgba(70,160,255,.92); }
  .u-red{ text-decoration-color: rgba(235,80,92,.92); }

  /* ===== Grid ===== */
  :is(.gridDock, #gridDock){
    display:block;
    width:fit-content;
    margin: 105px auto 0;
    position:relative;
    flex:0 0 auto;
    border-radius:14px;
    box-shadow:0 3px 8px rgba(0,0,0,.08);
    transition: box-shadow .45s ease;
    will-change: transform, box-shadow;
    z-index:20;
    isolation:isolate;
  }
  @media (pointer:coarse) and (max-width: 920px){
    :is(.gridDock, #gridDock){ margin-top: clamp(36px, 6.1vh, 62px); }
  }
  html.has-kb :is(.gridDock, #gridDock){ margin: 90px auto 0; }

  :is(.gridDock, #gridDock).shake{ animation:shake .16s linear 0s 2; }

  .wrap.solved:not(.gaveup) :is(.gridDock, #gridDock){
    pointer-events:none;
    transform: translate3d(0,-16px,0) scale(1.01);
    box-shadow:
      0 0 0 7px rgba(200,247,210,.55),
      0 0 0 13px rgba(200,247,210,.22),
      0 14px 26px rgba(0,0,0,.14);
    animation: solvedPop .46s ease-out both, glowPulse 1.15s ease-in-out 0s 2;
  }
  .wrap.gaveup :is(.gridDock, #gridDock){
    pointer-events:none;
    transform: translate3d(0,-16px,0) scale(1.01);
    box-shadow:
      0 0 0 7px rgba(255, 150, 160, .46),
      0 0 0 13px rgba(255, 150, 160, .20),
      0 14px 26px rgba(0,0,0,.14);
    animation: solvedPop .46s ease-out both, redPulse 1.15s ease-in-out 0s 2;
  }

  @keyframes solvedPop{
    0%{ transform: translate3d(0,-10px,0) scale(.985); }
    55%{ transform: translate3d(0,-20px,0) scale(1.02); }
    100%{ transform: translate3d(0,-16px,0) scale(1.01); }
  }
  @keyframes glowPulse{
    0%{
      box-shadow:
        0 0 0 7px rgba(200,247,210,.40),
        0 0 0 13px rgba(200,247,210,.16),
        0 14px 26px rgba(0,0,0,.14);
    }
    50%{
      box-shadow:
        0 0 0 7px rgba(200,247,210,.70),
        0 0 0 14px rgba(200,247,210,.28),
        0 16px 30px rgba(0,0,0,.16);
    }
    100%{
      box-shadow:
        0 0 0 7px rgba(200,247,210,.55),
        0 0 0 13px rgba(200,247,210,.22),
        0 14px 26px rgba(0,0,0,.14);
    }
  }
  @keyframes redPulse{
    0%{
      box-shadow:
        0 0 0 7px rgba(255,150,160,.32),
        0 0 0 13px rgba(255,150,160,.12),
        0 14px 26px rgba(0,0,0,.14);
    }
    50%{
      box-shadow:
        0 0 0 7px rgba(255,150,160,.60),
        0 0 0 14px rgba(255,150,160,.24),
        0 16px 30px rgba(0,0,0,.16);
    }
    100%{
      box-shadow:
        0 0 0 7px rgba(255,150,160,.46),
        0 0 0 13px rgba(255,150,160,.20),
        0 14px 26px rgba(0,0,0,.14);
    }
  }
  @keyframes shake{
    0%{ transform:translateX(0); }
    25%{ transform:translateX(-6px); }
    50%{ transform:translateX(6px); }
    75%{ transform:translateX(-4px); }
    100%{ transform:translateX(0); }
  }

  :is(.gridWrap, #gridWrap){
    display:block;
    border:4px solid var(--ink);
    border-radius:14px;
    overflow:hidden;
    background:#fff;
  }

  .grid{
    --n: 7;
    --gap: 3px;
    --cell: 44px;
    display:grid;
    grid-template-columns:repeat(var(--n), 1fr);
    gap: var(--gap);
    background: var(--ink);
    width: min(calc(var(--n) * var(--cell) + (var(--n) - 1) * var(--gap)), 92vw);
  }
  .cell{
    aspect-ratio:1/1;
    display:flex;
    align-items:center;
    justify-content:center;
    background:#fff;
    position:relative;
  }
  .cell.active::after{
    content:"";
    position:absolute;
    height:3px;
    width:62%;
    left:50%;
    bottom:12%;
    transform:translateX(-50%);
    background:var(--caret);
    border-radius:999px;
    animation: caretBlink 1.1s steps(2,end) infinite;
    pointer-events:none;
    opacity:1;
  }
  @keyframes caretBlink{
    0%, 46%{ opacity:1; }
    47%, 100%{ opacity:0; }
  }

  .cell input{
    width:100%;
    height:100%;
    border:0;
    outline:none;
    background:transparent;
    text-align:center;
    font-size:clamp(23px,5.1vw,32px);
    font-weight:900;
    font-style:italic;
    padding:0;
    margin:0;
    color:var(--ink);
    text-transform:lowercase;
    caret-color: transparent;
    cursor:text;
    appearance:none;
    -webkit-appearance:none;
    border-radius:0;
    user-select:none;
    -webkit-user-select:none;
  }
  .cell input::selection{ background:transparent; color:inherit; }

  .cell.bg-w1{ background:var(--w1); }
  .cell.bg-w2{ background:var(--w2); }
  .cell.bg-ol{ background:var(--ol); }
  .cell.bg-bad{ background:var(--bad) !important; }

  .cell.grabbable{ cursor:grab; }
  .cell.grabbable:active{ cursor:grabbing; }
  .cell.grabbable input{ pointer-events:none; cursor:grab; }

  html.has-kb .cell input{ pointer-events:none; }

  /* ===== Messages ===== */
  :is(.msgSlot, #msgSlot){
    position:relative;
    height:78px;
    width:100%;
    max-width:760px;
    margin: clamp(2px, 0.7vh, 6px) auto 0;
    flex:0 0 auto;
    pointer-events:none;
    transform: translateY(calc(-1 * var(--lift-msg) + var(--msg-drop)));
  }
  .wrap.solved :is(.msgSlot, #msgSlot){
    margin-top: clamp(0px, 0.4vh, 4px);
  }

  .msg{
    position:absolute;
    left:50%;
    top: 18px;
    margin:0;
    font-weight:900;
    opacity:0;
    transition:opacity .18s ease, transform .18s ease;
    font-style:italic;
    font-size:22px;
    pointer-events:none;
    width:max-content;
    max-width:min(92vw,760px);
    white-space: pre-line;
    line-height:1.15;
    text-align:center;

    /* keep X-centering, and allow per-type Y nudges via transforms */
    transform: translateX(-50%) translateY(0px);
  }

  .msg.show{ opacity:.92; }
  .msg.warn{ opacity:.92; font-size:20px; }

  /* (merged: you had .msg.result in two places) */
  .msg.result{
    top:12px;
    font-size:27px;
    transform: translateX(-50%) translateY(calc(var(--result-drop) - var(--msg-drop)));
  }

  .msg .msgLine{ display:block; }
  .msg.result .msgLine.score{
    font-size:26px;
    margin-top:6px;
  }
  .msg.result .msgLine.meta{
    font-size:14px;
    opacity:.55;
    margin-top:4px;
  }

  /* ===== Hint track + tiles ===== */
  :is(.hintTrack, #hintTrack){
    width:fit-content;
    max-width:min(920px,96vw);
    display:flex;
    align-items:center;
    justify-content:center;
    transition:opacity .35s ease, transform .35s ease;
  }

  /* ===== Bottom hint-track dock (dynamic placement) ===== */
  .hintDockBottom{
    width:100%;
    max-width:920px;
    margin: 8px auto 0;
    display:flex;
    justify-content:center;
    align-items:center;
    flex:0 0 auto;
    z-index:25;
    min-height:40px;
  }


  /* When using custom KB, buttons become fixed; keep the dock pinned above them */
  html.has-kb .hintDockBottom{
    position:fixed;
    left:0; right:0;
    bottom: calc(
      var(--kb-h) + env(safe-area-inset-bottom) + 36px
      + var(--btn-row-h, 0px) + 22px
    );
    margin:0;
    z-index:9996; /* below btnRow (9997) so buttons always win if overlap */
  }

  .trackRow{
    display:flex;
    align-items:flex-start;
    justify-content:center;
    gap:18px;
    flex-wrap:nowrap;
    transition: opacity .35s ease;
  }

  .trackBlock{
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:6px;
    min-width:0;
  }

  .letters{
    display:inline-flex;
    background:transparent;
    position:relative;
    flex:0 0 auto;
  }
  .letters.clickable{ cursor:pointer; }

  .letter{
    width:29px;
    height:29px;
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:900;
    font-style:italic;
    font-size:19px;
    text-transform:lowercase;
    background:rgba(255,255,255,.35);
    transition:opacity .15s ease, background .15s ease, transform .08s ease;
    border:1px solid rgba(0,0,0,.22);
    transform-origin:center;
  }
  .letter + .letter{ margin-left:-1px; }

  .letter.sel-w1{ background:var(--w1); }
  .letter.sel-w2{ background:var(--w2); }

  .letter.extra{
    background:rgba(255,255,255,.95);
    cursor:pointer;
    box-shadow:none;
  }
  .letter.extra:active{ transform:translateY(1px); }

  .extrasRow{
    display:flex;
    gap:10px;
    align-items:center;
    justify-content:center;
    flex-wrap:nowrap;
  }

  /* dim hint trigram tiles if that trigram is already in the main grid */
  .letters.is-in-grid .letter{ opacity:.38; }
  /* dim extra letters when they already exist as singles in the grid */
  #trackBox-extras .letter.is-in-grid{ opacity:.38; }

  /* ===== Hint fly overlay ===== */
  .hintSpotOverlay{
    position:fixed;
    inset:0;
    z-index:12000;
    pointer-events:none;
    display:block;
  }
  .hintSpot{
    position:fixed;
    left:50%;
    top:42%;
    transform: translate(-50%,-50%);
    display:inline-flex;
    align-items:center;
    justify-content:center;
    will-change: transform, filter, opacity;
  }
  .hintSpot.h1 .letter{ background: var(--w1); }
  .hintSpot.h2 .letter{ background: var(--w2); }
  .hintSpot.hex .letter{ background: rgba(255,255,255,.97); }

  /* ===== Skill dock + badge ===== */
  :is(.skillDock, #skillDock){
    margin: clamp(0px, 0.5vh, 6px) auto 0;
    width:fit-content;
    max-width:min(920px,96vw);
    min-height:74px;
    display:flex;
    align-items:center;
    justify-content:center;
    flex:0 0 auto;
    position:relative;
    transform: translateY(calc(-1 * var(--lift-hints)));
  }

  /* on reveal: fade track row away, keep the badge */
  .wrap.solved .trackRow{ opacity:0; }
  .wrap.solved .hintTrack{ pointer-events:none; opacity:1; }

  .skillBadge{
    position:absolute;
    left:50%;
    top:40%;
    transform:translate(-50%,-50%) translateY(var(--badge-drop)) scale(.84);
    opacity:0;
    pointer-events:none;
    transition: opacity .35s ease, transform .35s ease;
  }
  .wrap.solved .skillBadge{
    opacity:1;
    transform:translate(-50%,-50%) translateY(var(--badge-drop)) scale(.86);
    transition-delay:.06s;
  }

  .skillBadgeInner{
    position:relative;
    overflow:hidden;
    min-width:120px;
    padding:10px 14px;
    border-radius:16px;
    text-align:center;

    --txt: #2a1a00;
    --bdr: rgba(255, 220, 130, .65);
    --g1: rgba(255, 235, 180, .95);
    --g2: rgba(255, 200, 90,  .92);
    --g3: rgba(255, 240, 200, .96);
    --g4: rgba(255, 190, 70,  .92);

    color: var(--txt);
    border: 1px solid var(--bdr);
    background: linear-gradient(135deg, var(--g1) 0%, var(--g2) 35%, var(--g3) 70%, var(--g4) 100%);
    box-shadow:
      0 12px 26px rgba(255, 200, 80, .16),
      0 3px 10px rgba(0,0,0,.22);
  }

  .skillBadgeInner.gold{
    --txt:#2a1a00;
    --bdr: rgba(255, 220, 130, .70);
    --g1: rgba(255, 238, 190, .96);
    --g2: rgba(255, 205, 105, .94);
    --g3: rgba(255, 246, 210, .97);
    --g4: rgba(255, 185, 70,  .93);
    box-shadow:
      0 14px 28px rgba(255, 205, 95, .18),
      0 3px 10px rgba(0,0,0,.22);
  }

  .skillBadgeInner.silver{
    --txt:#1f2328;
    --bdr: rgba(200, 206, 215, .70);

    /* light steel, but clearly grey */
    --g1: rgba(238, 242, 247, .99);
    --g2: rgba(214, 222, 232, .96);
    --g3: rgba(242, 246, 250, .99);
    --g4: rgba(203, 212, 223, .95);

    box-shadow:
      0 12px 24px rgba(0,0,0,.12),
      0 3px 10px rgba(0,0,0,.20);
  }

  .skillBadgeInner.bronze{
    --txt:#2a1204;

    /* more subtle border */
    --bdr: rgba(190, 130, 95, .46);

    /* a touch more colour, still matte */
    --g1: rgba(248, 214, 190, .99);
    --g2: rgba(226, 170, 130, .96);
    --g3: rgba(250, 222, 205, .99);
    --g4: rgba(208, 150, 112, .95);

    box-shadow:
      0 12px 24px rgba(0,0,0,.12),
      0 3px 10px rgba(0,0,0,.20);
  }

  .skillBadgeInner.red{
    --txt:#160405;

    /* softer (less “outlined”) border */
    --bdr: rgba(150, 55, 60, .42);

    /* less white through the gradient; keep dark text readable */
    --g1: rgba(242, 208, 208, .99);
    --g2: rgba(220, 150, 148, .96);
    --g3: rgba(244, 214, 214, .99);
    --g4: rgba(195, 120, 120, .95);

    box-shadow:
      0 14px 28px rgba(0,0,0,.14),
      0 3px 10px rgba(0,0,0,.20);
  }

  .skillBadgeLabel{
    font-size:12px;
    font-weight:900;
    letter-spacing:.14em;
    text-transform:uppercase;
    opacity:.75;
  }
  .skillBadgeValue{
    font-size:34px;
    font-weight:950;
    line-height:1;
    margin-top:2px;
    text-shadow: 0 1px 0 rgba(255,255,255,.45);
  }

  .skillBadgeInner::before{
    content:"";
    position:absolute;
    inset:0;
    border-radius:inherit;
    background:
      radial-gradient(circle at 18% 28%, rgba(255,255,255,.85), transparent 38%),
      radial-gradient(circle at 78% 42%, rgba(255,255,255,.55), transparent 42%),
      radial-gradient(circle at 54% 86%, rgba(255,255,255,.35), transparent 48%);
    opacity:.55;
    pointer-events:none;
  }
  .skillBadgeInner::after{
    content:"";
    position:absolute;
    inset:0;
    border-radius:inherit;
    pointer-events:none;
    background: linear-gradient(110deg,
      transparent 0%,
      rgba(255,255,255,0) 38%,
      rgba(255,255,255,.70) 48%,
      rgba(255,255,255,0) 60%,
      transparent 100%);
    background-size:220% 100%;
    background-position:-120% 0;
    opacity:.55;
    mix-blend-mode: soft-light;
    animation: skillShine 1.6s ease-in-out infinite;
  }
  @keyframes skillShine{
    0%   { background-position:-120% 0; opacity:0; }
    15%  { opacity:.55; }
    55%  { opacity:.55; }
    100% { background-position:120% 0; opacity:0; }
  }
  @media (prefers-reduced-motion: reduce){
    .skillBadgeInner::after{ animation-duration:4.5s; opacity:.25; }
  }

  /* ===== Buttons ===== */
  :is(.btnRow, #btnRow){
    margin-top: clamp(18px, 3.8vh, 26px);
    display:flex;
    justify-content:center;
    gap:12px;
    flex-wrap:wrap;
    flex:0 0 auto;
    padding-bottom:2px;
    transition: opacity .35s ease, transform .35s ease;
  }

  /* fade buttons + floating hint track away on reveal */
  .wrap.solved :is(#btnRow, .btnRow){
    opacity:0;
    transform: translateY(6px);
    pointer-events:none;
  }
  .wrap.solved .hintTrackTop{
    opacity:0;
    pointer-events:none;
  }

  .btn{
    border:4px solid var(--ink);
    border-radius:999px;
    padding:9px 16px;
    min-width:104px;
    font-size:20px;
    font-weight:900;
    font-style:italic;
    color:var(--ink);
    background:rgba(255,255,255,.35);
    cursor:pointer;
    text-transform:lowercase;
    appearance:none;
    -webkit-appearance:none;
    box-shadow: 0 7px 0 rgba(0,0,0,.16);
  }
  .btn:active{
    transform:translateY(1px);
    box-shadow: 0 6px 0 rgba(0,0,0,.16);
  }
  .btn.hints{ background:#fff3bd; }
  .btn.check{ background:rgba(255,255,255,.25); opacity:.55; }
  .btn.check.ready{ opacity:1; background:var(--submit); }
  .btn:disabled{
    opacity:.35 !important;
    cursor:default;
    transform:none !important;
    box-shadow: 0 7px 0 rgba(0,0,0,.10);
  }

  html.has-kb :is(.btnRow, #btnRow){
    position:fixed;
    left:0; right:0;
    bottom: calc(var(--kb-h) + env(safe-area-inset-bottom) + 36px);
    margin:0;
    z-index:9997;
  }
  html.has-kb .btn{ border-width:3px; }

  /* ===== Ghost drag tile ===== */
  .ghost{
    position:fixed;
    z-index:9999;
    pointer-events:none;
    transform: translate(-50%, -50%);
    filter: drop-shadow(0 14px 16px rgba(0,0,0,.22));
    opacity:.95;
  }

  /* ===== Keyboard ===== */
  :is(.kbHost, #kbHost){
    position:fixed;
    left:0; right:0;
    bottom:0;
    z-index:9996;
    display:none;
    padding:10px 10px calc(22px + env(safe-area-inset-bottom));
    background:rgba(255,255,255,.90);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-top:2px solid rgba(0,0,0,.14);
  }
  html.has-kb :is(.kbHost, #kbHost){ display:block; }

  .kb{
    max-width:560px;
    margin:0 auto;
    display:flex;
    flex-direction:column;
    gap:8px;
    --keyW: clamp(28px, 8.6vw, 48px);
  }
  .kbRow{
    display:flex;
    justify-content:center;
    gap:4px;
  }
  .kbKey{
    width: var(--keyW);
    height: 48px;
    border:2px solid rgba(0,0,0,.16);
    border-radius:11px;
    background:rgba(255,255,255,.82);
    font-weight:700;
    font-style:normal;
    text-transform:none;
    font-size:18px;
    color: var(--ink);
    cursor:pointer;
  }
  .kbKey:active{ transform:translateY(1px); }

  .kbKey .kbIcon{
    width:24px;
    height:24px;
    display:block;
    margin:0 auto;
    pointer-events:none;
    user-select:none;
    -webkit-user-drag:none;
  }

  .kbKey.wide{
    width: calc(var(--keyW) * 1.55);
    font-size:12px;
    font-weight:900;
    letter-spacing:.08em;
    padding:0;
  }
  .kbKey.enter{
    font-size:11px;
    letter-spacing:.02em;
  }
  .kbKey.enter:not(.is-disabled){
    background: rgba(0,0,0,.07);
  }
  .kbKey.delete{
    font-size:16.3px;
    letter-spacing:.03em;
    font-weight:750;
    background: rgba(0,0,0,.07);
  }
  .kbKey.reset{
    font-size:13px;
    color: rgba(0, 0, 0, 0.6);
    letter-spacing:.01em;
    font-weight:700;
    background: rgba(0,0,0,.07); /* same as Delete */
  }

  .kbKey.is-disabled{
    opacity:.38;
    background: rgba(0,0,0,.04);
    border-color: rgba(0,0,0,.10);
    transform:none !important;
    cursor:default;
  }

  /* ===== Modal ===== */
  .modalOverlay{
    position:fixed;
    inset:0;
    background: rgba(0,0,0,.26);
    display:none;
    align-items:center;
    justify-content:center;
    z-index:10000;
    padding:14px;
  }
  .modalOverlay.open{ display:flex; }

  .modalCard{
    width: min(560px, 94vw);
    background:#fff;
    border-radius:18px;
    border:2px solid rgba(0,0,0,.15);
    box-shadow: 0 10px 26px rgba(0,0,0,.18);
    overflow:hidden;
    text-align:left;
  }
  .modalHdr{
    display:flex;
    align-items:center;
    justify-content:space-between;
    padding: 14px 14px 12px;
    border-bottom:1px solid rgba(0,0,0,.08);
    gap:10px;
  }
  .modalTitle{
    font-weight:950;
    font-size:18px;
    letter-spacing:.01em;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }
  .modalX{
    border:0;
    background:transparent;
    color:var(--ink);
    font-size:20px;
    line-height:1;
    font-weight:300;
    cursor:pointer;
    padding: 2px 6px;
    opacity:.9;
    outline:none !important;
    box-shadow:none !important;
    appearance:none;
    -webkit-appearance:none;
  }
  .modalX:active{ transform: translateY(1px); }
  .modalBody{ padding: 12px 14px 14px; }
  /* ===== Stats overlay ===== */
  .statsOverlay{
    position:fixed;
    inset:0;
    background:rgba(0,0,0,.26);
    display:none;
    align-items:center;
    justify-content:center;
    z-index:11000;
    padding:14px;
  }
  .statsOverlay.open{ display:flex; }

  .statsCard{
    width:min(560px,94vw);
    background:#fff;
    border-radius:18px;
    border:2px solid rgba(0,0,0,.15);
    box-shadow:0 10px 26px rgba(0,0,0,.18);
    overflow:hidden;
    text-align:left;
  }
  .statsHdr{
    display:flex;
    align-items:center;
    justify-content:space-between;
    padding:14px 14px 10px;
    border-bottom:1px solid rgba(0,0,0,.08);
    gap:10px;
  }
  .statsTitle{
    font-weight:950;
    font-size:18px;
    letter-spacing:.01em;
  }
  .statsX{
    border:0;
    background:transparent;
    color:var(--ink);
    font-size:20px;
    line-height:1;
    font-weight:300;
    cursor:pointer;
    padding:2px 6px;
    opacity:.9;
    outline:none !important;
    box-shadow:none !important;
    appearance:none;
    -webkit-appearance:none;
  }
  .statsX:active{ transform:translateY(1px); }

  .statsBody{
    padding:12px 14px 14px;
    max-height:min(520px,72vh);
    overflow:auto;
    font-size:14px;
  }
  .statsIntro{
    margin-bottom:10px;
    font-size:13px;
    opacity:.8;
  }
  .statsSection{
    margin-bottom:14px;
  }
  .statsSection h3{
    margin:0 0 4px;
    font-size:15px;
  }
  .statsSummary{
    margin:0 0 6px;
    font-size:13px;
    opacity:.85;
  }
  .statsCols{
    display:flex;
    gap:10px;
    flex-wrap:wrap;
  }
  .statsCol{
    flex:1 1 0;
    min-width:0;
  }
  .statsCol h4{
    margin:0 0 4px;
    font-size:12px;
    text-transform:uppercase;
    letter-spacing:.09em;
    opacity:.7;
  }
  .statRow{
    display:flex;
    align-items:center;
    gap:6px;
    margin-bottom:3px;
  }
  .statLabel{
    flex:0 0 64px;
    font-size:12px;
    opacity:.8;
  }
  .statBar{
    flex:1 1 auto;
    height:7px;
    border-radius:999px;
    background:rgba(0,0,0,.06);
    overflow:hidden;
  }
  .statBarFill{
    display:block;
    height:100%;
    border-radius:999px;
    background:linear-gradient(90deg, rgba(40,120,255,.9), rgba(110,200,255,.9));
  }
  .statValue{
    flex:0 0 auto;
    min-width:18px;
    text-align:right;
    font-size:12px;
  }
  .statsEmpty{
    margin:0 0 4px;
    font-size:13px;
    opacity:.75;
  }

  
  /* ===== Rotate overlay ===== */
  #rotateOverlay{
    display:none;
    position:fixed;
    inset:0;
    z-index:25000;
    background: rgba(169,205,243,.98);
    padding:
      calc(18px + env(safe-area-inset-top))
      16px
      calc(18px + env(safe-area-inset-bottom));
    align-items:center;
    justify-content:center;
    text-align:center;
  }
  #rotateOverlay .card{
    width: min(560px, 92vw);
    background: rgba(255,255,255,.92);
    border: 2px solid rgba(0,0,0,.16);
    border-radius: 18px;
    padding: 18px 16px;
    box-shadow: 0 10px 26px rgba(0,0,0,.18);
  }
  #rotateOverlay .title{
    margin: 0 0 8px;
    font-weight: 600;
    font-style: normal;
    font-size: 16px;
    line-height: 1.2;
    opacity: .78;
  }
  #rotateOverlay .body{
    margin: 0;
    font-weight: 950;
    font-size: 24px;
    line-height: 1.15;
  }
  #rotateOverlay .body b{ font-weight: inherit; }

  @media (pointer: coarse) and (orientation: landscape) and (max-height: 430px){
    #rotateOverlay{ display:flex; }
    :is(#wrap, .wrap){ pointer-events:none; opacity:.25; filter: blur(2px); }
    :is(#kbHost, .kbHost){ display:none !important; }
    #hintsModal{ display:none !important; }
  }

  /* ===== Mobile tweaks ===== */
  @media (max-width:520px){
    :root{
      --lift-msg: 34px;
      --lift-hints: 88px;
    }

    .nav :is(a, button){ padding:4px 9px; }

    .clue{
      font-size:clamp(32px,6.6vw,38px);
      margin-top: clamp(16px, 3.4vh, 28px);
    }

    .grid{
      --cell: 43px;
      width: min(calc(var(--n) * var(--cell) + (var(--n) - 1) * var(--gap)), 94vw);
    }
    .cell input{ font-size:clamp(24px,6.05vw,36px); }
    .letter{ width:28px; height:28px; font-size:19px; }

    .msgSlot{ height:84px; }
    .msg{ top:12px; font-size:20px; }
    .msg.warn{ font-size:19px; }
    .msg.result{ top:14px; font-size:25px; }

    .btn{ font-size:19px; padding:9px 15px; min-width:98px; }
    .kbKey{ height:46px; }
    .hintSpot{ top:40%; }

    .modePill{
      top:8px;
      right:10px;
      font-size:10px;
      padding:3px 8px;
    }

    .statsBtn{
      left:10px;
      top:8px;
      width:26px;
      height:26px;
    }
  }

    @media (min-width: 600px){
  .modePill{
    right: calc(50% - 300px + 12px);
  }
  .statsBtn{
    left: calc(50% - 300px + 12px);
  }
}

</style>


</head>

<body>
  <div class="wrap" id="wrap">

    <button class="statsBtn" id="statsBtn" type="button" aria-label="Show stats">
      <img src="stats-icon.svg" alt="" class="statsIcon">
    </button>

    <div class="toprow">
      <div class="nav">

        <a href="#" id="prevBtn" aria-label="Previous puzzle">‹</a>
        <span class="count" id="count"></span>
        <a href="#" id="nextBtn" aria-label="Next puzzle">›</a>
      </div>
    </div>
<div class="modePill" id="modePill" aria-label="Mode: Elite">Elite</div>
    
     <div class="clueWrap" id="clueWrap">
    <div class="clue" id="clue"></div>

    <!-- floating hint track UNDER the clue -->
    <div class="hintTrack hintTrackTop" id="hintTrack" aria-label="Hint tracker">
      <div class="trackRow" id="trackRow">
        <div class="trackBlock" id="trackW1"></div>
        <div class="trackBlock" id="trackW2"></div>
        <div class="trackBlock" id="trackExtras"></div>
      </div>
    </div>
  </div>

  <div class="gridDock" id="gridDock">
    <div class="gridWrap" id="gridWrap" aria-label="Answer grid">
      <div class="grid" id="grid" style="--n:7"></div>
    </div>
  </div>

  <div class="msgSlot" id="msgSlot" aria-live="polite">
    <div class="msg" id="msg"></div>
  </div>

  <!-- Skill badge lives in the OLD hint-track slot -->
  <div class="skillDock" id="skillDock" aria-label="Skill badge">
    <div class="skillBadge" id="skillBadge" aria-hidden="true">
      <div class="skillBadgeInner">
        <div class="skillBadgeLabel">Skill</div>
        <div class="skillBadgeValue" id="skillBadgeValue">—</div>
      </div>
    </div>
  </div>
  <!-- bottom hint-track dock (we move #hintTrack here when there’s room) -->
  <div class="hintDockBottom" id="hintDockBottom"></div>

  <div class="btnRow" id="btnRow">
    <button class="btn hints" id="hintsBtn" type="button">hint 1</button>
    <button class="btn check" id="checkBtn" type="button">check</button>
  </div>
</div>


  <div class="modalOverlay" id="hintsModal" aria-hidden="true">
    <div class="modalCard" role="dialog" aria-modal="true" aria-labelledby="hintsModalTitle">
      <div class="modalHdr">
        <div class="modalTitle" id="hintsModalTitle">Choose a hint</div>
        <button class="modalX" id="hintsModalClose" type="button" aria-label="Close">×</button>
      </div>
      <div class="modalBody" id="hintsModalBody"></div>
    </div>
  </div>

  <div class="kbHost" id="kbHost" aria-label="On-screen keyboard"></div>

  <!-- Stats overlay -->
  <div class="statsOverlay" id="statsOverlay" aria-hidden="true">
    <div class="statsCard" role="dialog" aria-modal="true" aria-labelledby="statsTitle">
      <div class="statsHdr">
        <div class="statsTitle" id="statsTitle">Your stats</div>
        <button class="statsX" id="statsClose" type="button" aria-label="Close stats">×</button>
      </div>
      <div class="statsBody" id="statsBody"></div>
    </div>
  </div>

  <div id="rotateOverlay" aria-hidden="true">
    <div class="card" role="alert">
      <p class="body"><b>Please rotate your device.</b></p>
      <p class="title">Oops! We can't fit everything on your screen.</p>
    </div>
  </div>



<script>
/* =======================
   Puzzles
   ======================= */
const PUZZLES = [
  { clue:"Danger mishaps", word1:"danger", word2:"mishaps", answer:"anguish", tri1:"ang", tri2:"ish" },
  { clue:"Blast updraft", word1:"blast", word2:"updraft", answer:"drastic", tri1:"ast", tri2:"dra" },
  { clue:"Ultra tinned", word1:"ultra", word2:"tinned", answer:"trained", tri1:"tra", tri2:"ned" },
  { clue:"Carbon refills", word1:"carbon", word2:"refills", answer:"careful", tri1:"car", tri2:"ref" },
  { clue:"Garage excimer", word1:"garage", word2:"excimer", answer:"ragtime", tri1:"rag", tri2:"ime" },
  { clue:"Flower, grieve", word1:"flower", word2:"grieve", answer:"however", tri1:"owe", tri2:"eve" },
  { clue:"Carrot chords", word1:"carrot", word2:"chords", answer:"horrors", tri1:"rro", tri2:"hor" },
  { clue:"Chimp poacher", word1:"chimp", word2:"poacher", answer:"impeach", tri1:"imp", tri2:"ach" },
  { clue:"Purport bruise", word1:"purport", word2:"bruise", answer:"mortise", tri1:"ort", tri2:"ise" },
  { clue:"Kitten suppose", word1:"kitten", word2:"suppose", answer:"rosette", tri1:"tte", tri2:"ose" },
  { clue:"Coach tinsel", word1:"coach", word2:"tinsel", answer:"coating", tri1:"coa", tri2:"tin" },
  { clue:"Final uniform", word1:"final", word2:"uniform", answer:"knifing", tri1:"fin", tri2:"nif" },
  { clue:"Changed similar", word1:"changed", word2:"similar", answer:"angular", tri1:"ang", tri2:"lar" },
  { clue:"Firefly clotted", word1:"firefly", word2:"clotted", answer:"refuted", tri1:"ref", tri2:"ted" },
  { clue:"Token angels", word1:"token", word2:"angels", answer:"kennels", tri1:"ken", tri2:"els" },
  { clue:"Scones rowboat", word1:"scones", word2:"rowboat", answer:"jawbone", tri1:"one", tri2:"wbo" },
  { clue:"Orange museums", word1:"orange", word2:"museums", answer:"mustang", tri1:"ang", tri2:"mus" },
  { clue:"Fairly acute", word1:"fairly", word2:"acute", answer:"haircut", tri1:"air", tri2:"cut" },
  { clue:"Gambit blitz", word1:"gambit", word2:"blitz", answer:"ambling", tri1:"amb", tri2:"bli" },
  { clue:"Greatly mythos", word1:"greatly", word2:"mythos", answer:"ghostly", tri1:"tly", tri2:"hos" },
  { clue:"Claims maximal", word1:"claims", word2:"maximal", answer:"malaise", tri1:"lai", tri2:"mal" },
  { clue:"Gates warmed", word1:"gates", word2:"warmed", answer:"mediate", tri1:"ate", tri2:"med" },
  { clue:"Mirage rides", word1:"mirage", word2:"rides", answer:"tirades", tri1:"ira", tri2:"des" },
  { clue:"Overt eyesore", word1:"overt", word2:"eyesore", answer:"forever", tri1:"ver", tri2:"ore" },
  { clue:"Planes catchup", word1:"planes", word2:"catchup", answer:"placate", tri1:"pla", tri2:"cat" },
  { clue:"Hover slimmed", word1:"hover", word2:"slimmed", answer:"slivers", tri1:"ver", tri2:"sli" },
  { clue:"Library trolley", word1:"library", word2:"trolley", answer:"braille", tri1:"bra", tri2:"lle" },
  { clue:"Tables augury", word1:"tables", word2:"augury", answer:"gurgles", tri1:"les", tri2:"gur" },
  { clue:"Sitting decoys", word1:"sitting", word2:"decoys", answer:"decking", tri1:"ing", tri2:"dec" },
  { clue:"Chopped vessel", word1:"chopped", word2:"vessel", answer:"oppress", tri1:"opp", tri2:"ess" },
  { clue:"Claimed module", word1:"claimed", word2:"module", answer:"medulla", tri1:"med", tri2:"dul" },
  { clue:"Broke gaucher", word1:"broke", word2:"gaucher", answer:"brother", tri1:"bro", tri2:"her" },
  { clue:"Peacock sifted", word1:"peacock", word2:"sifted", answer:"reacted", tri1:"eac", tri2:"ted" },
  { clue:"Spiel gashes", word1:"spiel", word2:"gashes", answer:"gasping", tri1:"spi", tri2:"gas" },
  { clue:"Child infant", word1:"child", word2:"infant", answer:"anthill", tri1:"hil", tri2:"ant" },
  { clue:"Tirade omitted", word1:"tirade", word2:"omitted", answer:"pirated", tri1:"ira", tri2:"ted" },
  { clue:"Cabinet wince", word1:"cabinet", word2:"wince", answer:"incline", tri1:"ine", tri2:"inc" },
  { clue:"Puppy loosest", word1:"puppy", word2:"loosest", answer:"suppose", tri1:"upp", tri2:"ose" },
  { clue:"Glory tension", word1:"glory", word2:"tension", answer:"sensory", tri1:"ory", tri2:"ens" },
  { clue:"Ankles ordeals", word1:"ankles", word2:"ordeals", answer:"realest", tri1:"les", tri2:"eal" },
  { clue:"Pains mudder", word1:"pains", word2:"mudder", answer:"insider", tri1:"ins", tri2:"der" },
  { clue:"Shame redrawn", word1:"shame", word2:"redrawn", answer:"dramedy", tri1:"ame", tri2:"dra" },
  { clue:"Aliens butch", word1:"aliens", word2:"butch", answer:"halibut", tri1:"ali", tri2:"but" },
  { clue:"Layers exempts", word1:"layers", word2:"exempts", answer:"tempers", tri1:"ers", tri2:"emp" },
  { clue:"Pride earths", word1:"pride", word2:"earths", answer:"sidearm", tri1:"ide", tri2:"ear" },
  { clue:"Space archer", word1:"space", word2:"archer", answer:"apaches", tri1:"pac", tri2:"che" },
  { clue:"Dweeb riddles", word1:"dweeb", word2:"riddles", answer:"tweedle", tri1:"wee", tri2:"dle" },
  { clue:"Lakes martyr", word1:"lakes", word2:"martyr", answer:"partake", tri1:"ake", tri2:"art" },
  { clue:"Naive fritter", word1:"naive", word2:"fritter", answer:"riveter", tri1:"ive", tri2:"ter" },
  { clue:"Wedlock cakes", word1:"wedlock", word2:"cakes", answer:"nakedly", tri1:"edl", tri2:"ake" },
  { clue:"Unholy outlay", word1:"unholy", word2:"outlay", answer:"holdout", tri1:"hol", tri2:"out" },
  { clue:"Hotter cowboy", word1:"hotter", word2:"cowboy", answer:"boycott", tri1:"ott", tri2:"boy" },
  { clue:"Slider snoops", word1:"slider", word2:"snoops", answer:"topside", tri1:"ide", tri2:"ops" },
  { clue:"Arrange armpits", word1:"arrange", word2:"armpits", answer:"impinge", tri1:"nge", tri2:"mpi" },
  { clue:"Eyelash grunge", word1:"eyelash", word2:"grunge", answer:"melange", tri1:"ela", tri2:"nge" },
  { clue:"Precise murder", word1:"precise", word2:"murder", answer:"decider", tri1:"eci", tri2:"der" },
  { clue:"Hanged heists", word1:"hanged", word2:"heists", answer:"ingests", tri1:"nge", tri2:"sts" },
  { clue:"Misty ampere", word1:"misty", word2:"ampere", answer:"persist", tri1:"ist", tri2:"per" },
];

const TR = 3;

const el = {
  wrap: document.getElementById('wrap'),
  clue: document.getElementById('clue'),
  gridDock: document.getElementById('gridDock'),
  gridWrap: document.getElementById('gridWrap'),
  grid: document.getElementById('grid'),
  msg: document.getElementById('msg'),

  clueWrap: document.getElementById('clueWrap'),
  msgSlot: document.getElementById('msgSlot'),
  hintDockBottom: document.getElementById('hintDockBottom'),

  hintTrack: document.getElementById('hintTrack'),
  trackW1: document.getElementById('trackW1'),
  trackW2: document.getElementById('trackW2'),
  trackExtras: document.getElementById('trackExtras'),

  hintsBtn: document.getElementById('hintsBtn'),
  checkBtn: document.getElementById('checkBtn'),
  btnRow: document.getElementById('btnRow'),

  prevBtn: document.getElementById('prevBtn'),
  nextBtn: document.getElementById('nextBtn'),
  count: document.getElementById('count'),

  kbHost: document.getElementById('kbHost'),

  hintsModal: document.getElementById('hintsModal'),
  hintsModalBody: document.getElementById('hintsModalBody'),
  hintsModalClose: document.getElementById('hintsModalClose'),

  modePill: document.getElementById('modePill'),

  // stats
  statsBtn: document.getElementById('statsBtn'),
  statsOverlay: document.getElementById('statsOverlay'),
  statsBody: document.getElementById('statsBody'),
  statsClose: document.getElementById('statsClose'),
};



const TWOTRI_TEXT   = "Two trigrams from same word";
const OVERLAP_TEXT  = "1-letter overlap allowed ✓";
const OVERLAP2_TEXT = "2-letter overlap not allowed";
const HINT_IDS = { w1:'w1', w2:'w2', extras:'extras' };

/* =======================
   State
   ======================= */
const state = {
  i: 0,
  finished: false,
  gaveUp: false,

  hintCount: 0,
  hintsUsed: { w1:false, w2:false, extras:false },

  assist: false,        // Enhanced mode (OFF by default)
  assistLocked: false,  // once ON this puzzle, can't be turned OFF (except reset)

  sel1: null,
  sel2: null,

  placed: { w1: null, w2: null },
  singles: [],
  bank: [],
  focusIdx: 0,

  drag: null,

  msgTimer: null,
  msgTransient: false,
  msgTransientEndsAt: 0,
  lockMsg: false,

  // Assist activation flash override
  assistFlashOn: false,
  assistFlashTimer: null,
  assistGlowTimer: null,
  assistPrevMsg: null,
  assistMsgQueue: null,

  // Skill scoring
  cycleCount: 0,
  wrongCheckCount: 0,
  preHint1Cycles: 0,
  postHint1Cycles: 0,
  effortUnits: 0,

  // segment scoring markers
  visibleMsAtPuzzleStart: 0,
  visibleMsAtSegmentStart: 0,
  effortAtSegmentStart: 0,
  wrongCheckCountAtSegmentStart: 0,
  wrongCarry: 0,

  // invalid states
  badSet: new Set(),
  badTris: { w1: new Set(), w2: new Set() },
  badRuns: { w1: [], w2: [] },

  twoSet: new Set(),
  twoTris: { w1: new Set(), w2: new Set() },

  ol2Set: new Set(),
  ol2Tris: { w1: new Set(), w2: new Set() },

  exclSet: new Set(),
  exclTris: { w1: new Set(), w2: new Set() },

  overlapMsgOn: false,

  useCustomKB: false,

  modalOpen: false,

  // hint fly
  pendingFly: null,
  flyAttempts: 0,
};

/* =======================
   Flags (Enhanced vs minimal)
   ======================= */
function flags(){
  if(state.assist){
    return {
      allowClueTapPlace: true,
      allowClueTapCycle: true,
      allowHintTapPlace: true,
      allowHint3TapInsert: true,
      allowDragTrigrams: true,
      allowAutoPromote: true,
      showGridColors: true,
      showStatusMessages: true,
      showBadCellColor: true,
      checkFeedback: "detailed",
    };
  }
  return {
    allowClueTapPlace: false,
    allowClueTapCycle: false,
    allowHintTapPlace: false,
    allowHint3TapInsert: false,
    allowDragTrigrams: false,
    allowAutoPromote: false,
    showGridColors: false,
    showStatusMessages: true,
    showBadCellColor: false,
    checkFeedback: "minimal",
  };
}
/* =======================
   Mode pill (Elite vs Classic)
   ======================= */
function updateModePill(){
  if(!el.modePill) return;
  const assistOn = !!state.assist;
  const label = assistOn ? "Classic" : "Elite";
  el.modePill.textContent = label;
  el.modePill.setAttribute("aria-label", `Mode: ${label}`);
}

/* =======================
   Helpers
   ======================= */
function uid(){ return Math.random().toString(16).slice(2) + Date.now().toString(16); }
function clamp(n,min,max){ return Math.max(min, Math.min(max, n)); }
function current(){ return PUZZLES[state.i]; }
function norm(s){ return String(s||"").toLowerCase().replace(/[^a-z]/g,""); }
function isAlpha(ch){ return /^[a-z]$/i.test(ch); }
function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

function getN(){
  const a = norm(current().answer);
  return clamp(a.length || 7, 6, 8);
}
function startMax(){ return Math.max(0, getN() - TR); }

function renderSmart(){
  render(!state.useCustomKB);
  requestAnimationFrame(updateHintTrackPlacement);
}

/* =======================
   Visible-time stopwatch
   ======================= */
let _visibleMsTotal = 0;
let _visibleStartTs = document.hidden ? null : performance.now();

function _visibleOnHide(){
  const now = performance.now();
  if(_visibleStartTs != null){
    _visibleMsTotal += (now - _visibleStartTs);
    _visibleStartTs = null;
  }
}
function _visibleOnShow(){
  if(_visibleStartTs == null) _visibleStartTs = performance.now();
}
document.addEventListener('visibilitychange', ()=>{
  if(document.hidden){
    _visibleOnHide();
    abortDrag();
  }else{
    _visibleOnShow();
  }
}, { passive:true });

function getVisibleMsNow(){
  const now = performance.now();
  return _visibleMsTotal + (_visibleStartTs != null ? (now - _visibleStartTs) : 0);
}

/* =======================
   Skill scoring
   ======================= */
function skillResetForPuzzle(){
  const vNow = getVisibleMsNow();
  state.visibleMsAtPuzzleStart = vNow;

  state.visibleMsAtSegmentStart = vNow;
  state.effortAtSegmentStart = (state.effortUnits || 0);
  state.wrongCheckCountAtSegmentStart = (state.wrongCheckCount || 0);
  state.wrongCarry = 0;
}

function addEffort(units){
  state.effortUnits = (state.effortUnits || 0) + (units || 0);
}

function snapshotGridChars(){
  const n = getN();
  const out = new Array(n);
  for(let i=0;i<n;i++) out[i] = String(cellChar(i) || "").toLowerCase();
  return out;
}
function countEffortFromGridChange(before, after, opts={}){
  const countDeletes = !!opts.countDeletes;
  let units = 0;
  const n = Math.min(before.length, after.length);
  for(let i=0;i<n;i++){
    const b = before[i] || "";
    const a = after[i] || "";
    if(a === b) continue;
    if(!countDeletes && !a) continue;
    units += 1;
  }
  return units;
}
function addEffortFromGridChange(before, opts={}){
  if(!before) return;
  const after = snapshotGridChars();
  const units = countEffortFromGridChange(before, after, opts);
  const base = Number(opts.base || 0);
  const total = base + units;
  if(total > 0) addEffort(total);
}

function skillBandForHints(h){
  if(h <= 0) return { min: 88, max: 100 };
  if(h === 1) return { min: 68, max: 87 };
  if(h === 2) return { min: 48, max: 67 };
  return { min: 30, max: 47 };
}

function skillStartNewSegmentAfterHint(){
  const wrongNow = (state.wrongCheckCount || 0);
  const wrongStart = (state.wrongCheckCountAtSegmentStart || 0);
  const dw = Math.max(0, wrongNow - wrongStart);

  const alpha = 0.5;
  state.wrongCarry = ((state.wrongCarry || 0) + dw) * alpha;

  const vNow = getVisibleMsNow();
  state.visibleMsAtSegmentStart = vNow;
  state.effortAtSegmentStart = (state.effortUnits || 0);
  state.wrongCheckCountAtSegmentStart = wrongNow;
}

function computeFinalSkill(gaveUp){
  if(gaveUp) return { skillRaw: 30, skill: 30 };

  const h = clamp(state.hintCount || 0, 0, 3);
  const { min: bandMin, max: bandMax } = skillBandForHints(h);

  const vNow = getVisibleMsNow();
  const vSeg = (typeof state.visibleMsAtSegmentStart === "number") ? state.visibleMsAtSegmentStart : vNow;
  const dt = Math.max(0, (vNow - vSeg) / 1000);

  const effNow = (state.effortUnits || 0);
  const effSeg = (typeof state.effortAtSegmentStart === "number") ? state.effortAtSegmentStart : 0;

  const RAW_BASE_E = getN();
  const BASE_E = Math.max(0, RAW_BASE_E - 2); 
  const de = Math.max(0, (effNow - effSeg) - BASE_E);

  const wrongNow = (state.wrongCheckCount || 0);
  const wrongSeg = (typeof state.wrongCheckCountAtSegmentStart === "number") ? state.wrongCheckCountAtSegmentStart : 0;
  const dw = Math.max(0, wrongNow - wrongSeg);

  const wrongEffective = dw + (state.wrongCarry || 0);
  const wrongW = 1.0;

  const Tref = [130, 130, 115, 90];
  const Eref = [30, 30, 26, 19];
  const k    = [0.31,0.29,0.27,0.25];

  const L = (dt / Tref[h]) + (de / Eref[h]) + (wrongW * wrongEffective);
  const span = (bandMax - bandMin);

  const skillRaw = bandMin + span * Math.exp(-k[h] * L);
  const skill = clamp(Math.round(skillRaw), bandMin, bandMax);
  return { skillRaw, skill };
}
/* =======================
   Local storage + stats
   ======================= */

const LS_KEY = "trigramGameStats_v1";

function hasLocalStorage(){
  try{
    return typeof window !== "undefined" && !!window.localStorage;
  }catch(e){
    return false;
  }
}

function loadStatsStore(){
  if(!hasLocalStorage()) return { results:{} };
  try{
    const raw = window.localStorage.getItem(LS_KEY);
    if(!raw) return { results:{} };
    const data = JSON.parse(raw);
    if(!data || typeof data !== "object") return { results:{} };
    if(!data.results || typeof data.results !== "object") data.results = {};
    return data;
  }catch(e){
    return { results:{} };
  }
}

function saveStatsStore(data){
  if(!hasLocalStorage()) return;
  try{
    window.localStorage.setItem(LS_KEY, JSON.stringify(data));
  }catch(e){}
}

function clearAllStats(){
  if(!hasLocalStorage()) return;
  try{
    window.localStorage.removeItem(LS_KEY);
  }catch(e){}
}

// Called whenever an answer is revealed (correct or give up)
function storeResultForCurrentPuzzle(skill, gaveUp){
  if(!hasLocalStorage()) return;
  const data = loadStatsStore();
  const id = String(state.i); // use puzzle index as key

  data.results[id] = {
    puzzleIndex: state.i,
    puzzleNumber: state.i + 1,
    hints: state.hintCount || 0,
    skill: skill,
    mode: state.assist ? "Classic" : "Elite",  // Classic = assist ON, Elite = assist OFF
    assistOn: !!state.assist,
    gaveUp: !!gaveUp,
    ts: Date.now()
  };

  saveStatsStore(data);
}

function getResultForPuzzle(idx){
  const data = loadStatsStore();
  return data.results[String(idx)] || null;
}

// First puzzle that does NOT have a stored result
function firstUnplayedPuzzleIndex(){
  const data = loadStatsStore();
  for(let i=0; i<PUZZLES.length; i++){
    if(!data.results || !Object.prototype.hasOwnProperty.call(data.results, String(i))){
      return i;
    }
  }
  // All completed; fall back to last puzzle
  return Math.max(0, PUZZLES.length - 1);
}

// Apply a stored result (if any) to the CURRENT puzzle index (state.i)
function applyStoredResultToCurrentPuzzle(){
  const saved = getResultForPuzzle(state.i);
  if(!saved) return false;

  const p = current();
  const ans = norm(p.answer);
  const n = getN();

  abortDrag();
  state.placed = {w1:null, w2:null};
  state.singles = [];
  for(let i=0; i<n; i++){
    state.singles.push({ id: uid(), ch: ans[i] || "", idx:i });
  }
  state.focusIdx = 0;

  state.finished = true;
  state.gaveUp = !!saved.gaveUp;
  state.hintCount = saved.hints || 0;

  state.assist = !!saved.assistOn;
  state.assistLocked = !!saved.assistOn;
  updateModePill();

  state.lockMsg = false;
  clearMsgTimer();
  setMsg("");

  const line1 = saved.gaveUp
    ? "You gave up!"
    : `Correct - ${hintPhraseText(state.hintCount)}!`;

  setResultSkillMsg(line1, saved.skill);
  renderSmart();
  return true;
}

function computeModeStats(modeLabel){
  const data = loadStatsStore();
  const all = Object.values(data.results || {});
  const arr = all.filter(r => r.mode === modeLabel);
  const count = arr.length;
  if(!count) return { count:0 };

  let sumHints = 0;
  let sumSkill = 0;
  const histSkill = { "88-100":0, "68-87":0, "48-67":0, "30-47":0 };
  const histHints = { 0:0, 1:0, 2:0, 3:0 };

  for(const r of arr){
    const h = clamp(r.hints || 0, 0, 3);
    const s = clamp(r.skill || 0, 0, 100);

    sumHints += h;
    sumSkill += s;

    if(s >= 88) histSkill["88-100"]++;
    else if(s >= 68) histSkill["68-87"]++;
    else if(s >= 48) histSkill["48-67"]++;
    else histSkill["30-47"]++;

    histHints[h] = (histHints[h] || 0) + 1;
  }
  return {
    count,
    avgHints: sumHints / count,
    avgSkill: sumSkill / count,
    histSkill,
    histHints
  };
}

function formatAvg(x, decimals){
  if(typeof x !== "number" || !isFinite(x)) return "—";
  return x.toFixed(decimals);
}

function totalCompletedCount(){
  const data = loadStatsStore();
  return data.results ? Object.keys(data.results).length : 0;
}

// ?reset in the URL clears stats and progress
function checkResetParam(){
  try{
    const qs = window.location.search || "";
    if(!qs) return;
    const params = new URLSearchParams(qs);
    if(params.has("reset")){
      clearAllStats();
    }
  }catch(e){}
}

function renderStatsView(){
  if(!el.statsBody) return;

  const total = totalCompletedCount();
  const classic = computeModeStats("Classic");
  const elite   = computeModeStats("Elite");

  function sectionHTML(label, stats){
    if(!stats || !stats.count){
      return `
        <section class="statsSection">
          <h3>${label}</h3>
          <p class="statsEmpty">No puzzles completed in this mode yet.</p>
        </section>`;
    }

    const hs = stats.histSkill;
    const hh = stats.histHints;
    const maxSkill = Math.max(
      hs["88-100"] || 0,
      hs["68-87"] || 0,
      hs["48-67"] || 0,
      hs["30-47"] || 0
    );
    const maxHints = Math.max(
      hh[0] || 0,
      hh[1] || 0,
      hh[2] || 0,
      hh[3] || 0
    );

    const skillRow = (lbl, key) => {
      const v = hs[key] || 0;
      const w = maxSkill ? Math.round((v / maxSkill) * 100) : 0;
      return `
        <div class="statRow">
          <span class="statLabel">${lbl}</span>
          <span class="statBar"><span class="statBarFill" style="width:${w}%"></span></span>
          <span class="statValue">${v}</span>
        </div>`;
    };

    const hintRow = (lbl, key) => {
      const v = hh[key] || 0;
      const w = maxHints ? Math.round((v / maxHints) * 100) : 0;
      return `
        <div class="statRow">
          <span class="statLabel">${lbl}</span>
          <span class="statBar"><span class="statBarFill" style="width:${w}%"></span></span>
          <span class="statValue">${v}</span>
        </div>`;
    };

    return `
      <section class="statsSection">
        <h3>${label}</h3>
        <p class="statsSummary">${stats.count} puzzles • Avg hints ${formatAvg(stats.avgHints,1)} • Avg skill ${formatAvg(stats.avgSkill,0)}</p>
        <div class="statsCols">
          <div class="statsCol">
            <h4>Skill</h4>
            ${skillRow("88–100", "88-100")}
            ${skillRow("68–87", "68-87")}
            ${skillRow("48–67", "48-67")}
            ${skillRow("30–47", "30-47")}
          </div>
          <div class="statsCol">
            <h4>Hints used</h4>
            ${hintRow("0", 0)}
            ${hintRow("1", 1)}
            ${hintRow("2", 2)}
            ${hintRow("3+", 3)}
          </div>
        </div>
      </section>`;
  }

  el.statsBody.innerHTML = `
    <div class="statsIntro">
      <p><strong>${total}</strong> puzzles completed so far.</p>
    </div>
    ${sectionHTML("Classic (assist on)", classic)}
    ${sectionHTML("Elite (assist off)", elite)}
  `;
}

function openStats(){
  if(!el.statsOverlay) return;
  el.statsOverlay.classList.add('open');
  el.statsOverlay.setAttribute('aria-hidden', 'false');
  renderStatsView();
}


function closeStats(){
  if(!el.statsOverlay) return;
  el.statsOverlay.classList.remove('open');
  el.statsOverlay.setAttribute('aria-hidden', 'true');
}

/* =======================
   UI small helpers
   ======================= */
function shakeGrid(){
  el.gridDock.classList.remove('shake');
  void el.gridDock.offsetWidth;
  el.gridDock.classList.add('shake');
  setTimeout(()=> el.gridDock.classList.remove('shake'), 420);
}

document.addEventListener('contextmenu', (e)=>{
  const t = e.target;
  if(t && t.closest && t.closest('#clue, #gridDock, #gridWrap, #hintTrack, #skillDock, #btnRow, #kbHost, #hintsModal')){
    e.preventDefault();
  }
});

/* =======================
   Enhanced toggle (no persistence)
   ======================= */
function setEnhanced(on, renderNow=true, source='auto'){
  const next = !!on;

  // Enhanced can ONLY be turned ON by explicit user intent.
  if(next && source !== 'user') return;

  // Once locked on this puzzle, can't turn off (except reset).
  if(state.assistLocked && !next && source !== 'reset') return;

  if(state.assist === next) return;

  state.assist = next;

  // No more glow/message – just update the tiny mode pill
  updateModePill();

  if(next) state.assistLocked = true;
  if(!next) abortDrag();

  if(renderNow) renderSmart();
}


function resetEnhancedForNewPuzzle(){
  state.assist = false;
  state.assistLocked = false;
  abortDrag();
  updateModePill();
}


/* =======================
   Messages
   ======================= */
function clearMsgTimer(){
  if(state.msgTimer){ clearTimeout(state.msgTimer); state.msgTimer=null; }
  state.msgTransient = false;
  state.msgTransientEndsAt = 0;
}

function setMsgDirect(text, kind){
  clearMsgTimer();
  el.msg.classList.remove('show','warn','result','assistFlash');
  el.msg.textContent = text || "";
  if(!text) return;
  void el.msg.offsetWidth;
  el.msg.classList.add('show');
  if(kind === 'warn') el.msg.classList.add('warn');
  if(kind === 'result') el.msg.classList.add('result');
}
function setMsg(text, kind){
  if(state.assistFlashOn){
    state.assistMsgQueue = { text: text || "", kind: kind || null, transient:false };
    return;
  }
  setMsgDirect(text, kind);
}
function setTransientMsgDirect(text, ms=2400, kind=null){
  setMsgDirect(text, kind);
  state.msgTransient = true;
  state.msgTransientEndsAt = performance.now() + ms;

  state.msgTimer = setTimeout(()=>{
    el.msg.classList.remove('show','warn','result','assistFlash');
    el.msg.textContent = "";
    state.msgTimer = null;
    state.msgTransient = false;
    state.msgTransientEndsAt = 0;
  }, ms);
}
function setTransientMsg(text, ms=2400, kind=null){
  if(state.assistFlashOn){
    state.assistMsgQueue = { text: text || "", kind: kind || null, transient:true, ms: ms || 2400 };
    return;
  }
  setTransientMsgDirect(text, ms, kind);
}

function clearTransientOnAnyChange(){
  if(state.assistFlashOn) return;
  if(state.lockMsg){
    state.lockMsg = false;
    setMsg("");
  }
  if(state.msgTransient){
    el.msg.classList.remove('show','warn','result');
    el.msg.textContent = "";
    clearMsgTimer();
  }
}

function excludedMsgText(){
  const n = (state.exclTris?.w1?.size || 0) + (state.exclTris?.w2?.size || 0);
  return (n >= 2) ? "Your hints excluded these trigrams" : "Your hint excluded this trigram";
}

const ASSIST_FLASH_MS = 4200;
const CLUE_GLOW_MS    = 3200;

function triggerAssistActivatedUI(){
  if(state.finished) return;

  // glow flash on clue
  if(state.assistGlowTimer){ clearTimeout(state.assistGlowTimer); state.assistGlowTimer = null; }
  if(el.clue){
    el.clue.classList.remove('assist-glow');
    void el.clue.offsetWidth;
    el.clue.classList.add('assist-glow');
    state.assistGlowTimer = setTimeout(()=>{
      el.clue.classList.remove('assist-glow');
      state.assistGlowTimer = null;
    }, CLUE_GLOW_MS);
  }

  // capture current message (pause transient timer if needed)
  const now = performance.now();
  state.assistPrevMsg = {
    text: el.msg.textContent || "",
    kind: el.msg.classList.contains('warn') ? 'warn'
         : el.msg.classList.contains('result') ? 'result'
         : null,
    wasShown: el.msg.classList.contains('show') && !!el.msg.textContent,
    transient: state.msgTransient,
    remaining: state.msgTransient ? Math.max(0, (state.msgTransientEndsAt || 0) - now) : 0
  };

  if(state.msgTransient && state.msgTimer){
    clearTimeout(state.msgTimer);
    state.msgTimer = null;
  }
  state.msgTransient = false;
  state.msgTransientEndsAt = 0;

  state.assistMsgQueue = null;
  state.assistFlashOn = true;

  el.msg.classList.remove('show','warn','result');
  el.msg.textContent = "Assist mode activated";
  void el.msg.offsetWidth;
  el.msg.classList.add('assistFlash');

  if(state.assistFlashTimer){ clearTimeout(state.assistFlashTimer); state.assistFlashTimer = null; }
  state.assistFlashTimer = setTimeout(()=>{
    state.assistFlashOn = false;
    state.assistFlashTimer = null;

    el.msg.classList.remove('assistFlash');
    el.msg.textContent = "";
    el.msg.classList.remove('show','warn','result');

    const q = state.assistMsgQueue;
    state.assistMsgQueue = null;
    if(q && q.text){
      if(q.transient) setTransientMsgDirect(q.text, q.ms, q.kind);
      else setMsgDirect(q.text, q.kind);
      state.assistPrevMsg = null;
      return;
    }

    const prev = state.assistPrevMsg;
    state.assistPrevMsg = null;
    if(prev && prev.wasShown && prev.text){
      if(prev.transient && prev.remaining > 0) setTransientMsgDirect(prev.text, prev.remaining, prev.kind);
      else setMsgDirect(prev.text, prev.kind);
      return;
    }

    updateStatusMessages();
  }, ASSIST_FLASH_MS);
}

/* =======================
   Modal
   ======================= */
function closeModal(){
  if(!state.modalOpen) return;
  el.hintsModal.classList.remove('open');
  el.hintsModal.setAttribute('aria-hidden', 'true');
  state.modalOpen = false;

  requestAnimationFrame(()=>{
    if(!state.useCustomKB && !state.finished) focusCell(state.focusIdx ?? 0);
  });
}
el.hintsModal.addEventListener('pointerdown', (e)=>{
  if(e.target === el.hintsModal){ e.preventDefault(); e.stopPropagation(); closeModal(); }
},{passive:false});
el.hintsModalClose.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); closeModal(); });

document.addEventListener('keydown', (e)=>{
  if(!state.modalOpen) return;
  if(e.key === "Escape"){
    e.preventDefault();
    closeModal();
  }else{
    if(e.key && e.key.length === 1) e.preventDefault();
    if(e.key === "Backspace" || e.key === "Delete" || e.key === "Enter") e.preventDefault();
  }
}, {capture:true});

/* =======================
   Clue helpers
   ======================= */
function splitClueTwoWords(clue){
  const s = String(clue||"").trim();
  const m = s.match(/^(\S+)\s+(\S+)\s*$/);
  if(m) return [m[1], m[2]];
  const parts = s.split(/\s+/).filter(Boolean);
  return [parts[0]||"", parts[1]||""];
}

function underlineBySubstrings(token, items){
  const chars = Array.from(token);
  const map=[];
  let clean="";
  for(let i=0;i<chars.length;i++){
    if(/[A-Za-z]/.test(chars[i])){ map.push(i); clean += chars[i].toLowerCase(); }
  }
  if(!clean) return escapeHtml(token);

  const clsAt = new Array(chars.length).fill(null);
  const prio = (cls)=> (cls === "u-red" ? 3 : (cls === "u-w1" || cls === "u-w2" ? 2 : 1));

  for(const it of items){
    const sub = norm(it.sub);
    if(!sub) continue;
    let pos = clean.indexOf(sub);
    while(pos >= 0){
      for(let k=0;k<sub.length;k++){
        const oi = map[pos+k];
        if(oi == null) continue;
        const cur = clsAt[oi];
        if(!cur || prio(it.cls) >= prio(cur)) clsAt[oi] = it.cls;
      }

      // underline apostrophes inside match span
      const oi0 = map[pos];
      const oi1 = map[pos + sub.length - 1];
      if(oi0 != null && oi1 != null){
        const lo = Math.min(oi0, oi1), hi = Math.max(oi0, oi1);
        for(let j = lo; j <= hi; j++){
          if(chars[j] === "'" || chars[j] === "’"){
            const cur = clsAt[j];
            if(!cur || prio(it.cls) >= prio(cur)) clsAt[j] = it.cls;
          }
        }
      }

      pos = clean.indexOf(sub, pos + 1);
    }
  }

  let out = "";
  let open = null;
  for(let i=0;i<chars.length;i++){
    const c = chars[i];
    const cls = clsAt[i];
    if(cls !== open){
      if(open) out += "</span>";
      if(cls) out += `<span class="${cls}">`;
      open = cls || null;
    }
    out += escapeHtml(c);
  }
  if(open) out += "</span>";
  return out;
}

/* =======================
   Grid model + focus
   ======================= */
function trigramCells(start){ return [start, start+1, start+2]; }

function gridIndexFromPoint(x,y){
  const els = document.elementsFromPoint ? document.elementsFromPoint(x,y) : [document.elementFromPoint(x,y)];
  for(const n of els){
    if(!n) continue;
    const cell = n.closest ? n.closest('.cell') : null;
    if(cell && cell.dataset && cell.dataset.idx != null){
      const idx = Number(cell.dataset.idx);
      if(Number.isFinite(idx)) return idx;
    }
  }
  return null;
}

function overlapCount(aStart, bStart){
  const aset = new Set(trigramCells(aStart));
  let c=0;
  for(const i of trigramCells(bStart)) if(aset.has(i)) c++;
  return c;
}
function overlapMatchIdx(aStart, bStart){
  const aset = new Set(trigramCells(aStart));
  for(const i of trigramCells(bStart)) if(aset.has(i)) return i;
  return null;
}

function trigramAtIndex(idx){
  for(const group of ['w1','w2']){
    const pl = state.placed[group];
    if(!pl) continue;
    if(idx >= pl.start && idx < pl.start + TR){
      return {group, start: pl.start, tri: pl.tri, offset: idx - pl.start};
    }
  }
  return null;
}
function singleAt(idx){
  return state.singles.find(s => s.idx === idx) || null;
}
function cellChar(idx){
  const t = trigramAtIndex(idx);
  if(t) return t.tri[t.offset];
  const s = singleAt(idx);
  if(s) return s.ch;
  return "";
}
function removeSinglesInCells(cells){
  const set = new Set(cells);
  state.singles = state.singles.filter(s => !set.has(s.idx));
}
function deleteTrigramGroup(group){
  if(!state.placed[group]) return false;
  const start = state.placed[group].start;
  state.placed[group] = null;
  state.focusIdx = clamp(start, 0, getN()-1);
  return true;
}
function deleteAtIndex(idx){
  const t = trigramAtIndex(idx);
  if(t) return deleteTrigramGroup(t.group);
  const s = singleAt(idx);
  if(s){
    state.singles = state.singles.filter(x => x.idx !== idx);
    state.focusIdx = clamp(idx, 0, getN()-1);
    return true;
  }
  return false;
}
function focusCell(idx){
  const n = getN();
  const i = clamp(idx, 0, n-1);
  state.focusIdx = i;
  if(state.useCustomKB) return;

  const inp = el.grid.querySelector(`input[data-idx="${i}"]`);
  if(inp){
    inp.focus({preventScroll:true});
    try{
      const len = inp.value ? inp.value.length : 0;
      inp.setSelectionRange(len, len);
    }catch{}
  }
}

/* =======================
   Grid helpers
   ======================= */
function gridHasExactTrigram(tri){
  const t = norm(tri);
  if(!t || t.length !== 3) return false;

  const n = getN();
  for(let s=0; s<=n-3; s++){
    const a = cellChar(s), b = cellChar(s+1), c = cellChar(s+2);
    if(!a || !b || !c) continue;
    if(((a+b+c).toLowerCase()) === t) return true;
  }
  return false;
}

function updateExtrasHintFade(){
  const row = document.getElementById('trackBox-extras');
  if(!row) return;

  const counts = Object.create(null);
  for(const s of (state.singles || [])){
    const ch = String(s.ch || "").toLowerCase();
    if(!ch) continue;
    counts[ch] = (counts[ch] || 0) + 1;
  }
  const remaining = Object.assign(Object.create(null), counts);

  row.querySelectorAll('.letter').forEach(l => l.classList.remove('is-in-grid'));
  row.querySelectorAll('.letter').forEach(l=>{
    const ch = String(l.textContent || "").trim().toLowerCase();
    if(remaining[ch] > 0){
      l.classList.add('is-in-grid');
      remaining[ch]--;
    }
  });
}

/* =======================
   Typing
   ======================= */
function nextEditableFrom(startIdx, dir){
  const n = getN();
  let i = clamp(startIdx, 0, n-1);
  while(i >= 0 && i < n){
    if(!trigramAtIndex(i)) return i;
    i += dir;
  }
  return null;
}

function typeLetterAtIndex(idx, ch){
  const n = getN();
  const lower = ch.toLowerCase();

  const prev = String(cellChar(idx) || "").toLowerCase();
  if(prev !== lower) addEffort(1);

  state.singles = state.singles.filter(x => x.idx !== idx);
  state.singles.push({id: uid(), ch: lower, idx});

  const next = nextEditableFrom(idx + 1, +1);
  state.focusIdx = (next == null) ? clamp(idx + 1, 0, n-1) : next;
}

function typeLetterIntoGrid(letter){
  if(state.finished) return false;
  if(state.modalOpen) return false;

  const ch = String(letter || "").slice(0,1);
  if(!isAlpha(ch)) return false;

  clearTransientOnAnyChange();

  const n = getN();
  let idx = clamp(state.focusIdx ?? 0, 0, n-1);
  if(trigramAtIndex(idx)){
    const found = nextEditableFrom(idx, +1);
    if(found == null) return false;
    idx = found;
  }

  typeLetterAtIndex(idx, ch);
  renderSmart();
  return true;
}

function backspaceAtIndex(i){
  const n = getN();
  const idx = clamp(i ?? (state.focusIdx ?? 0), 0, n-1);

  const tHere = trigramAtIndex(idx);
  if(tHere){
    if(idx === tHere.start && tHere.start > 0){
      const left = tHere.start - 1;
      const tLeft = trigramAtIndex(left);
      if(tLeft) deleteTrigramGroup(tLeft.group);
      else if(singleAt(left)) deleteAtIndex(left);
      else state.focusIdx = left;
      return true;
    }
    deleteTrigramGroup(tHere.group);
    return true;
  }

  if(singleAt(idx)){ deleteAtIndex(idx); return true; }
  if(idx === 0) return false;

  if(deleteAtIndex(idx - 1)) return true;
  state.focusIdx = clamp(idx - 1, 0, n-1);
  return true;
}

function deleteFromEnd(){
  if(state.finished) return false;
  const n = getN();
  for(let i=n-1;i>=0;i--){
    if(!cellChar(i)) continue;
    const t = trigramAtIndex(i);
    if(t){ deleteTrigramGroup(t.group); return true; }
    if(singleAt(i)){
      state.singles = state.singles.filter(x => x.idx !== i);
      state.focusIdx = clamp(i,0,n-1);
      return true;
    }
  }
  return false;
}

/* =======================
   Typed trigram auto-promotion (Enhanced only)
   ======================= */
function allowedSet(group){
  const p = current();
  const w = norm(group==='w1' ? p.word1 : p.word2);
  const out = new Set();
  if(w.length < TR) return out;
  for(let i=0;i<=w.length-TR;i++) out.add(w.slice(i,i+TR));
  return out;
}
function overlapIsValid(aStart, aTri, bStart, bTri){
  const ol = overlapCount(aStart, bStart);
  if(ol === 0) return true;
  if(ol !== 1) return false;
  const common = overlapMatchIdx(aStart, bStart);
  const aCh = aTri[common - aStart];
  const bCh = bTri[common - bStart];
  return aCh === bCh;
}
function candidatesForTyped(group){
  if(state.placed[group]) return [];
  const set = allowedSet(group);
  if(!set.size) return [];

  const n = getN();
  const otherGroup = group==='w1' ? 'w2' : 'w1';
  const other = state.placed[otherGroup];

  const out=[];
  for(let s=0; s<=n-TR; s++){
    let chars = [];
    let borrowed = 0;
    let ok = true;

    for(let k=0;k<TR;k++){
      const idx = s + k;
      const t = trigramAtIndex(idx);
      if(t){
        if(t.group !== otherGroup){ ok = false; break; }
        borrowed++;
        chars.push(t.tri[t.offset]);
      }else{
        const sn = state.singles.find(x=>x.idx===idx);
        if(!sn){ ok = false; break; }
        chars.push(sn.ch);
      }
    }
    if(!ok) continue;
    if(borrowed > 1) continue;

    const tri = chars.join("").toLowerCase();
    if(!set.has(tri)) continue;

    if(other){
      const ol = overlapCount(s, other.start);
      if(ol > 1) continue;
      if(ol === 1 && !overlapIsValid(s, tri, other.start, other.tri)) continue;
      if(borrowed === 1 && ol !== 1) continue;
    }else{
      if(borrowed !== 0) continue;
    }

    out.push({start:s, tri});
  }
  return out;
}
function setMiniHighlightToTri(group, tri){
  const p = current();
  const w = norm(group==='w1' ? p.word1 : p.word2);
  const pos = w.indexOf(tri);
  const maxStart = Math.max(0, w.length - TR);
  if(pos >= 0){
    if(group==='w1') state.sel1 = clamp(pos, 0, maxStart);
    else state.sel2 = clamp(pos, 0, maxStart);
  }else{
    if(group==='w1') state.sel1 = 0;
    else state.sel2 = 0;
  }
}
function promoteTypedCandidate(group, cand){
  if(!cand) return false;
  if(state.placed[group]) return false;

  const otherGroup = group==='w1' ? 'w2' : 'w1';
  const other = state.placed[otherGroup];
  if(other){
    if(overlapCount(cand.start, other.start) > 1) return false;
    if(!overlapIsValid(cand.start, cand.tri, other.start, other.tri)) return false;
  }

  state.placed[group] = {start: cand.start, tri: cand.tri};
  removeSinglesInCells(trigramCells(cand.start));
  setMiniHighlightToTri(group, cand.tri);
  return true;
}
function autoPromoteTypedTrigrams(){
  if(state.finished) return false;
  if(!flags().allowAutoPromote) return false;

  let changed = false;
  const c1 = candidatesForTyped('w1');
  const c2 = candidatesForTyped('w2');

  let w1Cand = (c1.length === 1) ? c1[0] : null;
  let w2Cand = (c2.length === 1) ? c2[0] : null;

  if(w1Cand && w2Cand){
    if(overlapCount(w1Cand.start, w2Cand.start) > 1) { w1Cand = null; w2Cand = null; }
    else if(!overlapIsValid(w1Cand.start, w1Cand.tri, w2Cand.start, w2Cand.tri)) { w1Cand = null; w2Cand = null; }
  }

  if(w1Cand && w2Cand && !state.placed.w1 && !state.placed.w2){
    state.placed.w1 = {start: w1Cand.start, tri: w1Cand.tri};
    state.placed.w2 = {start: w2Cand.start, tri: w2Cand.tri};
    removeSinglesInCells(trigramCells(w1Cand.start));
    removeSinglesInCells(trigramCells(w2Cand.start));
    setMiniHighlightToTri('w1', w1Cand.tri);
    setMiniHighlightToTri('w2', w2Cand.tri);
    changed = true;
  }else{
    if(w1Cand && !state.placed.w1) if(promoteTypedCandidate('w1', w1Cand)) changed = true;
    if(w2Cand && !state.placed.w2) if(promoteTypedCandidate('w2', w2Cand)) changed = true;
  }

  return changed;
}

/* =======================
   Overlap helpers
   ======================= */
function overlapActiveNow(){
  const a = state.placed.w1, b = state.placed.w2;
  if(!a || !b) return false;
  if(overlapCount(a.start, b.start) !== 1) return false;
  return overlapIsValid(a.start, a.tri, b.start, b.tri);
}
function computeOverlapIdxSet(){
  const a = state.placed.w1, b = state.placed.w2;
  const set = new Set();
  if(!a || !b) return set;
  if(overlapCount(a.start, b.start) !== 1) return set;
  const common = overlapMatchIdx(a.start, b.start);
  if(common == null) return set;
  const aCh = a.tri[common - a.start];
  const bCh = b.tri[common - b.start];
  if(aCh === bCh) set.add(common);
  return set;
}

/* =======================
   Puzzle derivation (tri positions)
   ======================= */
function ensurePuzzleDerived(p){
  const ans = norm(p.answer);
  p.tri1 = norm(p.tri1 || "");
  p.tri2 = norm(p.tri2 || "");

  if(typeof p.tri1_pos !== "number"){
    p.tri1_pos = (p.tri1 && ans.includes(p.tri1)) ? ans.indexOf(p.tri1) : 0;
  }
  if(typeof p.tri2_pos !== "number"){
    if(p.tri2 && ans.includes(p.tri2)){
      const first = ans.indexOf(p.tri2);
      const second = ans.indexOf(p.tri2, first + 1);
      p.tri2_pos = first;
      if(p.tri1 && p.tri2 && first === p.tri1_pos && second !== -1) p.tri2_pos = second;
    }else{
      p.tri2_pos = 0;
    }
  }
}

/* =======================
   Invalid / excluded detection
   ======================= */
function compressMaximalStrings(arr){
  const uniq = Array.from(new Set(arr.filter(Boolean)));
  uniq.sort((a,b)=> b.length - a.length);
  const kept = [];
  for(const s of uniq){
    if(!kept.some(k => k.includes(s))) kept.push(s);
  }
  return kept;
}

function computeMax3Invalid(){
  const n = getN();
  const p = current();
  const w1 = norm(p.word1);
  const w2 = norm(p.word2);

  state.badSet = new Set();
  state.badTris = { w1: new Set(), w2: new Set() };
  const runsW1 = [];
  const runsW2 = [];

  const chars = Array.from({length:n}, (_,i)=>cellChar(i));
  let i=0;

  while(i<n){
    if(!chars[i]){ i++; continue; }
    let j=i;
    while(j<n && chars[j]) j++;
    const len = j - i;

    if(len >= 4){
      for(let a=i; a<j; a++){
        for(let b=a+4; b<=j; b++){
          const s = chars.slice(a,b).join("").toLowerCase();
          const inW1 = (w1 && w1.includes(s));
          const inW2 = (w2 && w2.includes(s));
          if(inW1 || inW2){
            for(let k=a;k<b;k++) state.badSet.add(k);
            for(let t=0; t<=s.length-3; t++){
              const tri = s.slice(t,t+3);
              if(inW1) state.badTris.w1.add(tri);
              if(inW2) state.badTris.w2.add(tri);
            }
            if(inW1) runsW1.push(s);
            if(inW2) runsW2.push(s);
          }
        }
      }
    }
    i = j;
  }

  state.badRuns.w1 = compressMaximalStrings(runsW1);
  state.badRuns.w2 = compressMaximalStrings(runsW2);
}

function computeTwoTrigramsInvalid(){
  const n = getN();
  const p = current();
  const w1 = norm(p.word1);
  const w2 = norm(p.word2);

  state.twoSet = new Set();
  state.twoTris = { w1: new Set(), w2: new Set() };

  const chars = Array.from({length:n}, (_,i)=>cellChar(i));
  const occ = { w1: [], w2: [] };

  for(let s=0; s<=n-3; s++){
    if(!chars[s] || !chars[s+1] || !chars[s+2]) continue;
    const tri = (chars[s] + chars[s+1] + chars[s+2]).toLowerCase();
    if(w1 && w1.includes(tri)) occ.w1.push({start:s, tri});
    if(w2 && w2.includes(tri)) occ.w2.push({start:s, tri});
  }

  for(const group of ['w1','w2']){
    if(occ[group].length >= 2){
      for(const o of occ[group]){
        state.twoTris[group].add(o.tri);
        for(const k of trigramCells(o.start)) state.twoSet.add(k);
      }
    }
  }
}

function computeHintExcludedTrigrams(){
  state.exclSet = new Set();
  state.exclTris = { w1: new Set(), w2: new Set() };

  const n = getN();
  const p = current();
  const chars = Array.from({length:n}, (_,i)=>cellChar(i));

  function scan(group, word, locked){
    const w = norm(word);
    if(!w) return;
    for(let s=0; s<=n-3; s++){
      if(!chars[s] || !chars[s+1] || !chars[s+2]) continue;
      const tri = (chars[s]+chars[s+1]+chars[s+2]).toLowerCase();
      if(locked && tri === locked) continue;
      if(w.includes(tri)){
        state.exclTris[group].add(tri);
        state.exclSet.add(s); state.exclSet.add(s+1); state.exclSet.add(s+2);
      }
    }
  }

  if(state.hintsUsed.w1) scan('w1', p.word1, norm(p.tri1));
  if(state.hintsUsed.w2) scan('w2', p.word2, norm(p.tri2));
}

function computeTwoLetterOverlapInvalid(){
  state.ol2Set = new Set();
  state.ol2Tris = { w1: new Set(), w2: new Set() };

  const n = getN();
  const p = current();
  const w1 = norm(p.word1);
  const w2 = norm(p.word2);
  if(!w1 || !w2) return;

  const set1 = new Set();
  const set2 = new Set();
  for(let i=0;i<=w1.length-TR;i++) set1.add(w1.slice(i,i+TR));
  for(let i=0;i<=w2.length-TR;i++) set2.add(w2.slice(i,i+TR));

  const a = state.placed?.w1;
  const b = state.placed?.w2;
  if(a && b && overlapCount(a.start, b.start) === 2){
    state.ol2Tris.w1.add(a.tri);
    state.ol2Tris.w2.add(b.tri);
    for(const k of trigramCells(a.start)) state.ol2Set.add(k);
    for(const k of trigramCells(b.start)) state.ol2Set.add(k);
  }

  const chars = Array.from({length:n}, (_,i)=>cellChar(i));

  const occW2ByStart = new Map();
  for(let s=0; s<=n-3; s++){
    if(!chars[s] || !chars[s+1] || !chars[s+2]) continue;
    const tri = (chars[s]+chars[s+1]+chars[s+2]).toLowerCase();
    if(set2.has(tri)){
      if(!occW2ByStart.has(s)) occW2ByStart.set(s, []);
      occW2ByStart.get(s).push(tri);
    }
  }

  for(let s=0; s<=n-3; s++){
    if(!chars[s] || !chars[s+1] || !chars[s+2]) continue;
    const tri1 = (chars[s]+chars[s+1]+chars[s+2]).toLowerCase();
    if(!set1.has(tri1)) continue;

    for(const s2 of [s-1, s+1]){
      const hits2 = occW2ByStart.get(s2);
      if(!hits2) continue;

      for(const tri2 of hits2){
        state.ol2Tris.w1.add(tri1);
        state.ol2Tris.w2.add(tri2);
        for(const k of trigramCells(s))  state.ol2Set.add(k);
        for(const k of trigramCells(s2)) state.ol2Set.add(k);
      }
    }
  }
}

/* =======================
   Hint extras letters
   ======================= */
function computeHint3Letters(){
  const n = getN();
  const p = current();
  const ans = norm(p.answer);
  const covered = new Set();
  const t1 = clamp(p.tri1_pos || 0, 0, n-3);
  const t2 = clamp(p.tri2_pos || 0, 0, n-3);

  for(let k=0;k<3;k++) covered.add(t1 + k);
  for(let k=0;k<3;k++) covered.add(t2 + k);

  const leftover = [];
  for(let i=0;i<n;i++) if(!covered.has(i)) leftover.push(ans[i]);
  leftover.sort();
  return leftover;
}
function rebuildBank(){
  state.bank = computeHint3Letters().map(ch => ({id: uid(), ch}));
}

/* =======================
   Status messages
   ======================= */
function updateStatusMessages(){
  if(state.assistFlashOn) return;
  if(state.finished) return;
  if(state.lockMsg) return;
  if(state.msgTransient) return;

  computeTwoLetterOverlapInvalid();
  computeMax3Invalid();
  computeTwoTrigramsInvalid();
  computeHintExcludedTrigrams();

  const hasOL2  = (state.ol2Set && state.ol2Set.size > 0);
  const hasMax3 = (state.badSet && state.badSet.size > 0);
  const hasTwo  = (state.twoSet && state.twoSet.size > 0);
  const hasExcl = (state.exclSet && state.exclSet.size > 0);

  if(hasOL2){
    setMsg(OVERLAP2_TEXT, 'warn');
    state.overlapMsgOn = false;
    return;
  }
  if(hasMax3){
    setMsg("Max 3 contiguous letters allowed", "warn");
    state.overlapMsgOn = false;
    return;
  }
  if(hasTwo){
    setMsg(TWOTRI_TEXT, "warn");
    state.overlapMsgOn = false;
    return;
  }
  if(hasExcl){
    setMsg(excludedMsgText(), "warn");
    state.overlapMsgOn = false;
    return;
  }

  if(el.msg.classList.contains('warn')) setMsg("");

  const hasOverlap = state.assist && overlapActiveNow();
  if(hasOverlap){
    if(el.msg.textContent !== OVERLAP_TEXT || el.msg.classList.contains('warn')) setMsg(OVERLAP_TEXT);
    state.overlapMsgOn = true;
  }else{
    if(state.overlapMsgOn && el.msg.textContent === OVERLAP_TEXT) setMsg("");
    if(!state.assist && el.msg.textContent === OVERLAP_TEXT) setMsg("");
    state.overlapMsgOn = false;
  }
}

/* =======================
   Check logic
   ======================= */
function canEnableCheckNow(){
  const n = getN();
  for(let i=0;i<n;i++) if(!cellChar(i)) return false;
  return true;
}
function countTrigramsInWord(attempt, word){
  const n = attempt.length;
  const w = norm(word);
  const found = [];
  if(!w) return found;
  for(let s=0; s<=n-3; s++){
    const tri = attempt.slice(s, s+3);
    if(w.includes(tri)) found.push(tri);
  }
  return found;
}
function hintPhraseText(h){
  if(h === 0) return "with no hints";
  if(h === 1) return "with 1 hint";
  return `with ${h} hints`;
}

function setResultSkillMsg(line1, skill){
  clearMsgTimer();
  el.msg.classList.remove('show','warn','result');

  el.msg.innerHTML = `<div class="msgLine">${escapeHtml(line1)}</div>`;

  const badgeVal = document.getElementById('skillBadgeValue');
  if(badgeVal) badgeVal.textContent = String(skill);

  const inner = document.querySelector('#skillBadge .skillBadgeInner');
  if(inner){
    inner.classList.remove('gold','silver','bronze','red');
    const tier = (skill >= 88) ? 'gold' : (skill >= 68) ? 'silver' : (skill >= 48) ? 'bronze' : 'red';
    inner.classList.add(tier);
  }

  const badge = document.getElementById('skillBadge');
  if(badge) badge.setAttribute('aria-label', `Skill ${skill}`);

  void el.msg.offsetWidth;
  el.msg.classList.add('show','result');
}

function onCheck(){
  if(state.finished) return;
  if(state.modalOpen) return;
  clearTransientOnAnyChange();

  const n = getN();
  if(!canEnableCheckNow()){
    setTransientMsg(`Fill all ${n}`, 1400);
    return;
  }

  computeMax3Invalid();
  computeTwoTrigramsInvalid();
  computeHintExcludedTrigrams();

  const attempt = Array.from({length:n}, (_,i)=>cellChar(i)).join("").toLowerCase();
  const p = current();
  const ans = norm(p.answer);

    if(attempt === ans){
    const res = computeFinalSkill(false);
    setResultSkillMsg(`Correct - ${hintPhraseText(state.hintCount)}!`, res.skill);
    state.finished = true;
    state.gaveUp = false;

    // record local-storage result (Classic vs Elite based on state.assist)
    storeResultForCurrentPuzzle(res.skill, false);

    renderSmart();
    return;
  }

  state.wrongCheckCount = (state.wrongCheckCount || 0) + 1;
  shakeGrid();

  if(flags().checkFeedback === "minimal"){
    renderSmart();
    return;
  }

  if(state.badSet.size){ setMsg("Max 3 contiguous letters allowed", "warn"); renderSmart(); return; }
  if(state.twoSet.size){ setMsg(TWOTRI_TEXT, "warn"); renderSmart(); return; }
  if(state.exclSet.size){ setMsg(excludedMsgText(), "warn"); renderSmart(); return; }

  const w1Hits = countTrigramsInWord(attempt, p.word1);
  const w2Hits = countTrigramsInWord(attempt, p.word2);

  let msg = "";
  if(w1Hits.length === 0 && w2Hits.length === 0) msg = "You didn’t use any trigrams";
  else if(w1Hits.length === 0) msg = "No trigram from word 1";
  else if(w2Hits.length === 0) msg = "No trigram from word 2";
  else if(w1Hits.length > 1 || w2Hits.length > 1) msg = TWOTRI_TEXT;

  if(msg){
    state.lockMsg = true;
    setMsg(msg, "warn");
  }else{
    setMsg("");
  }

  renderSmart();
}

/* =======================
   Give up
   ======================= */
function extrasUnlocked(){
  return state.hintsUsed.w1 && state.hintsUsed.w2;
}

function abortDrag(){
  if(!state.drag) return;
  try{ state.drag.ghost?.remove(); }catch{}
  state.drag = null;
}

window.addEventListener('blur', ()=> abortDrag());
window.addEventListener('focus', ()=>{}); // intentional no-op; keep behavior stable

function revealAnswerGiveUp(){
  if(state.finished) return;

  const p = current();
  const ans = norm(p.answer);
  const n = getN();

  abortDrag();
  state.placed = {w1:null, w2:null};
  state.singles = [];
  for(let i=0;i<n;i++){
    state.singles.push({id: uid(), ch: ans[i] || "", idx:i});
  }
  state.focusIdx = 0;

    const res = computeFinalSkill(true);

  state.finished = true;
  state.gaveUp = true;

  state.lockMsg = false;
  clearMsgTimer();
  setMsg("");

  setResultSkillMsg("You gave up!", res.skill);

  // record local-storage result as a “gave up” game
  storeResultForCurrentPuzzle(res.skill, true);

  renderSmart();
}


/* =======================
   Hint fly animation
   ======================= */
function makeSpotLettersHTML(chars, mode){
  const spot = document.createElement('div');
  spot.className = `hintSpot ${mode}`;

  const wrap = document.createElement('div');
  wrap.className = "letters";

  let perLetterClass = "";
  if(mode === "h1") perLetterClass = "sel-w1";
  else if(mode === "h2") perLetterClass = "sel-w2";
  else if(mode === "hex") perLetterClass = "extra";

  for(const ch of chars){
    const d = document.createElement('div');
    d.className = `letter ${perLetterClass}`.trim();
    d.textContent = ch;
    wrap.appendChild(d);
  }

  spot.appendChild(wrap);
  return spot;
}

function hintFlyKeyframes(dx, dy, startScale){
  const SH0 = 'drop-shadow(0 22px 22px rgba(0,0,0,.26))';
  const SH1 = 'drop-shadow(0 14px 14px rgba(0,0,0,.18))';
  const SH2 = 'drop-shadow(0 7px 7px rgba(0,0,0,.11))';
  const SH3 = 'drop-shadow(0 2px 2px rgba(0,0,0,.06))';
  const SH4 = 'drop-shadow(0 0 0 rgba(0,0,0,0))';

  const dx1 = dx * 0.78;
  const dy1 = dy * 0.78;
  const dx2 = dx * 0.93;
  const dy2 = dy * 0.93;

  return [
    { transform: `translate(-50%,-50%) scale(${startScale})`, filter: SH0, opacity: 1, offset: 0.00 },
    { transform: `translate(-50%,-50%) scale(${startScale})`, filter: SH0, opacity: 1, offset: 0.56 },
    { transform: `translate(-50%,-50%) translate3d(${dx1}px, ${dy1}px, 0) scale(1.14)`, filter: SH1, opacity: 1, offset: 0.82 },
    { transform: `translate(-50%,-50%) translate3d(${dx2}px, ${dy2}px, 0) scale(1.03)`, filter: SH2, opacity: 1, offset: 0.92 },
    { transform: `translate(-50%,-50%) translate3d(${dx}px, ${dy}px, 0) scale(1.00)`, filter: SH3, opacity: 1, offset: 0.965 },
    { transform: `translate(-50%,-50%) translate3d(${dx}px, ${dy}px, 0) scale(1.00)`, filter: SH4, opacity: 1, offset: 0.992 },
    { transform: `translate(-50%,-50%) translate3d(${dx}px, ${dy}px, 0) scale(1.00)`, filter: SH4, opacity: 1, offset: 1.00 }
  ];
}

function revealTargetInstant(tEl){
  if(!tEl) return;
  tEl.style.transition = 'none';
  tEl.style.opacity = '';
  requestAnimationFrame(()=> requestAnimationFrame(()=>{ tEl.style.transition = ''; }));
}

function runHintFlyExtrasSequential(targetRow, chars){
  if(!targetRow) return false;
  const targets = Array.from(targetRow.querySelectorAll('.letter'));
  if(!targets.length) return false;

  for(const t of targets) t.style.opacity = "0";

  const overlay = document.createElement('div');
  overlay.className = "hintSpotOverlay";
  document.body.appendChild(overlay);

  const total = Math.min(chars.length, targets.length);
  let idx = 0;

  const flyOne = ()=>{
    if(idx >= total){
      for(const t of targets) revealTargetInstant(t);
      requestAnimationFrame(()=> { try{ overlay.remove(); }catch{} });
      return;
    }

    const ch = chars[idx];
    const tEl = targets[idx];

    const spot = makeSpotLettersHTML([ch], 'hex');
    overlay.appendChild(spot);

    const sr = spot.getBoundingClientRect();
    const tr = tEl.getBoundingClientRect();

    const scx = sr.left + sr.width/2;
    const scy = sr.top + sr.height/2;
    const tcx = tr.left + tr.width/2;
    const tcy = tr.top + tr.height/2;

    let dx = tcx - scx;
    let dy = tcy - scy;
    dx = Math.round(dx * 2) / 2;
    dy = Math.round(dy * 2) / 2;

    const coarse = window.matchMedia && window.matchMedia('(pointer:coarse)').matches;
    const startScale = coarse ? 2.05 : 2.15;

    const DURATION = 860;
    const anim = spot.animate(hintFlyKeyframes(dx, dy, startScale), {
      duration: DURATION,
      easing: 'cubic-bezier(.14,.88,.22,1)',
      fill: 'forwards'
    });

    const early = setTimeout(()=> revealTargetInstant(tEl), DURATION - 34);

    anim.onfinish = ()=>{
      clearTimeout(early);
      revealTargetInstant(tEl);

      requestAnimationFrame(()=>{
        try{ spot.remove(); }catch{}
        idx++;
        requestAnimationFrame(flyOne);
      });
    };
  };

  requestAnimationFrame(flyOne);
  return true;
}

function runHintFly(kind){
  let target = null;
  let mode = 'hex';
  let chars = [];

  const p = current();

  if(kind === 'w1'){
    target = document.getElementById('trackBox-w1');
    mode = 'h1';
    chars = Array.from(norm(p.tri1));
  }else if(kind === 'w2'){
    target = document.getElementById('trackBox-w2');
    mode = 'h2';
    chars = Array.from(norm(p.tri2));
  }else if(kind === 'extras'){
    const row = document.getElementById('trackBox-extras');
    if(state.bank.length === 0) rebuildBank();
    chars = state.bank.map(t=>t.ch);
    return runHintFlyExtrasSequential(row, chars);
  }

  if(!target || !chars.length) return false;

  target.style.opacity = "0";

  const overlay = document.createElement('div');
  overlay.className = "hintSpotOverlay";

  const spot = makeSpotLettersHTML(chars, mode);
  overlay.appendChild(spot);
  document.body.appendChild(overlay);

  const sr = spot.getBoundingClientRect();
  const tr = target.getBoundingClientRect();

  const scx = sr.left + sr.width/2;
  const scy = sr.top + sr.height/2;
  const tcx = tr.left + tr.width/2;
  const tcy = tr.top + tr.height/2;

  let dx = tcx - scx;
  let dy = tcy - scy;
  dx = Math.round(dx * 2) / 2;
  dy = Math.round(dy * 2) / 2;

  const coarse = window.matchMedia && window.matchMedia('(pointer:coarse)').matches;
  const startScale = coarse ? 2.05 : 2.15;

  const anim = spot.animate(hintFlyKeyframes(dx, dy, startScale), {
    duration: 860,
    easing: 'cubic-bezier(.14,.88,.22,1)',
    fill: 'forwards'
  });

  anim.onfinish = ()=>{
    target.style.opacity = "1";
    requestAnimationFrame(()=>{ try{ overlay.remove(); }catch{} });
  };

  return true;
}

function scheduleHintFly(kind){
  state.pendingFly = kind;
  state.flyAttempts = 0;

  const tryRun = ()=>{
    if(!state.pendingFly) return;
    state.flyAttempts++;

    // Make sure the hint track is already in its correct slot
    // (top under the clue when keyboard is present, bottom dock otherwise)
    updateHintTrackPlacement();

    if(runHintFly(state.pendingFly)){
      state.pendingFly = null;
      state.flyAttempts = 0;
      return;
    }

    if(state.flyAttempts < 6){
      requestAnimationFrame(tryRun);
    }else{
      const map = {w1:'trackBox-w1', w2:'trackBox-w2', extras:'trackBox-extras'};
      const id = map[state.pendingFly]||"";
      const t = document.getElementById(id);

      if(state.pendingFly === 'extras'){
        const row = document.getElementById('trackBox-extras');
        if(row) row.querySelectorAll('.letter').forEach(x => x.style.opacity = "");
      }else{
        if(t) t.style.opacity = "1";
      }

      state.pendingFly = null;
      state.flyAttempts = 0;
    }
  };

  requestAnimationFrame(tryRun);
}


/* =======================
   Drag ghost + drag logic
   ======================= */
function trigramIsRedAtStart(start){
  computeTwoLetterOverlapInvalid();
  computeMax3Invalid();
  computeTwoTrigramsInvalid();
  computeHintExcludedTrigrams();

  for(const idx of trigramCells(start)){
    if(state.ol2Set.has(idx) || state.badSet.has(idx) || state.twoSet.has(idx) || state.exclSet.has(idx)) return true;
  }
  return false;
}

function makeGhostBox(text, bg){
  const ghost = document.createElement('div');
  ghost.className = "ghost";
  ghost.style.display = "flex";
  ghost.style.alignItems = "center";
  ghost.style.justifyContent = "center";
  ghost.style.borderRadius = "12px";
  ghost.style.border = "4px solid var(--ink)";
  ghost.style.fontWeight = "900";
  ghost.style.fontStyle = "italic";
  ghost.style.textTransform = "lowercase";
  ghost.style.background = bg;
  ghost.textContent = text;
  document.body.appendChild(ghost);
  return ghost;
}
function moveGhost(e){
  if(!state.drag) return;
  state.drag.ghost.style.left = e.clientX + "px";
  state.drag.ghost.style.top = e.clientY + "px";
}
function beginDragWithThreshold(e, startFn){
  const startX = e.clientX, startY = e.clientY;
  let started = false;

  const onMove = (ev)=>{
    const dx = ev.clientX - startX;
    const dy = ev.clientY - startY;
    if(!started && (dx*dx + dy*dy) > 144){
      started = true;
      clearTransientOnAnyChange();
      startFn(ev);
    }
    if(started){
      ev.preventDefault();
      onDragMove(ev);
    }
  };
  const onUp = (ev)=>{
    window.removeEventListener('pointermove', onMove);
    window.removeEventListener('pointercancel', onCancel);
    if(started) onDragEnd(ev);
  };
  const onCancel = ()=>{
    window.removeEventListener('pointermove', onMove);
    window.removeEventListener('pointerup', onUp);
    window.removeEventListener('pointercancel', onCancel);
    abortDrag();
    renderSmart();
  };

  window.addEventListener('pointermove', onMove, {passive:false});
  window.addEventListener('pointerup', onUp, {once:true});
  window.addEventListener('pointercancel', onCancel, {once:true});
}
function startDragTrigram(ev, group, tri, idx0, start0){
  const isRed = trigramIsRedAtStart(start0);
  const bg = isRed ? "var(--bad)" : (group === 'w1' ? "var(--w1)" : "var(--w2)");

  const ghost = makeGhostBox(tri, bg);
  ghost.style.width = "112px";
  ghost.style.height = "40px";
  ghost.style.letterSpacing = ".18em";

  const beforeChars = snapshotGridChars();

  state.drag = {
    kind:'trigram',
    group,
    tri,
    grabOffset: idx0 - start0,
    ghost,
    lastIdx:null,
    beforeChars
  };
  moveGhost(ev);
}

function pairForDragPinnedThenPush(group, desiredStart, idxNow){
  const mine = state.placed[group];
  const otherGroup = group==='w1' ? 'w2' : 'w1';
  const other = state.placed[otherGroup];
  if(!mine || !other){
    return { mineStart: clamp(desiredStart, 0, startMax()), otherStart: other ? other.start : null };
  }

  const currM = mine.start;
  const currO = other.start;
  const mineLeft = currM <= currO;

  const pointerInsideOther = (idxNow >= currO && idxNow < currO + 3);
  const idxInto = idxNow - currO;
  const olNow = overlapCount(currM, currO);

  const deepPush = pointerInsideOther && (
    mineLeft
      ? (idxInto >= (olNow === 1 ? 1 : 2))
      : (idxInto <= (olNow === 1 ? 1 : 0))
  );

  if(!deepPush){
    let sM = clamp(desiredStart, 0, startMax());
    const sO = currO;

    if(mineLeft){
      const maxNoTouch = sO - 3;
      const overlapStart = sO - 2;
      if(sM > maxNoTouch){
        if(overlapStart >= 0 && overlapStart <= startMax() && overlapIsValid(overlapStart, mine.tri, sO, other.tri)){
          sM = overlapStart;
        } else if(maxNoTouch >= 0){
          sM = maxNoTouch;
        } else {
          sM = currM;
        }
      }
    }else{
      const minNoTouch = sO + 3;
      const overlapStart = sO + 2;
      if(sM < minNoTouch){
        if(overlapStart >= 0 && overlapStart <= startMax() && overlapIsValid(overlapStart, mine.tri, sO, other.tri)){
          sM = overlapStart;
        } else if(minNoTouch <= startMax()){
          sM = minNoTouch;
        } else {
          sM = currM;
        }
      }
    }
    return { mineStart: clamp(sM, 0, startMax()), otherStart: sO };
  }

  let best = null;
  const currOl = olNow;

  for(let sM=0; sM<=startMax(); sM++){
    for(let sO=0; sO<=startMax(); sO++){
      const ol = overlapCount(sM, sO);
      if(ol > 1) continue;
      if(ol === 1 && !overlapIsValid(sM, mine.tri, sO, other.tri)) continue;

      const orderFlip = ((currM <= currO) !== (sM <= sO));

      let cost = 12*Math.abs(sM - desiredStart) + 5*Math.abs(sO - currO) + 2*Math.abs(ol - currOl);
      if(orderFlip) cost += (olNow === 1 ? 2 : 8);
      if(pointerInsideOther && ol === 0) cost -= 1;

      if(best == null || cost < best.cost) best = {cost, sM, sO};
    }
  }

  if(!best) return { mineStart: clamp(desiredStart,0,startMax()), otherStart: currO };
  return { mineStart: best.sM, otherStart: best.sO };
}

function onDragMove(e){
  if(!state.drag) return;
  moveGhost(e);

  const idxNow = gridIndexFromPoint(e.clientX, e.clientY);
  if(idxNow == null) return;
  if(state.drag.lastIdx === idxNow) return;
  state.drag.lastIdx = idxNow;

  const d = state.drag;
  if(d.kind !== 'trigram') return;

  const group = d.group;
  const otherGroup = group==='w1' ? 'w2' : 'w1';

  const mine = state.placed[group];
  const other = state.placed[otherGroup];
  if(!mine) return;

  const rawStart = idxNow - d.grabOffset;
  const desired = clamp(rawStart, 0, startMax());

  if(!other){
    mine.start = desired;
    removeSinglesInCells(trigramCells(mine.start));
    renderSmart();
    return;
  }

  const pair = pairForDragPinnedThenPush(group, desired, idxNow);
  mine.start = pair.mineStart;
  other.start = pair.otherStart;

  removeSinglesInCells(trigramCells(mine.start));
  removeSinglesInCells(trigramCells(other.start));
  renderSmart();
}

function rectDistance(x,y,rect){
  const dx = (x < rect.left) ? (rect.left - x) : (x > rect.right ? x - rect.right : 0);
  const dy = (y < rect.top) ? (rect.top - y) : (y > rect.bottom ? y - rect.bottom : 0);
  return Math.hypot(dx,dy);
}
function onDragEnd(e){
  if(!state.drag) return;
  const d = state.drag;
  const before = d.beforeChars;

  try{ d.ghost.remove(); }catch{}
  state.drag = null;

  const rect = el.gridWrap.getBoundingClientRect();
  const dist = rectDistance(e.clientX, e.clientY, rect);
  const REMOVE_DIST = 150;

  if(dist > REMOVE_DIST){
    deleteTrigramGroup(d.group);
  }

  addEffortFromGridChange(before, { countDeletes:true, base:0.5 });
  renderSmart();
}

/* =======================
   Underline logic
   ======================= */
function errorItemsForGroup(group){
  if(state.badRuns[group] && state.badRuns[group].length){
    return state.badRuns[group].map(s => ({sub:s, cls:"u-red"}));
  }
  if(state.ol2Tris[group] && state.ol2Tris[group].size){
    return Array.from(state.ol2Tris[group]).map(t => ({sub:t, cls:"u-red"}));
  }
  if(state.twoTris[group] && state.twoTris[group].size){
    return Array.from(state.twoTris[group]).map(t => ({sub:t, cls:"u-red"}));
  }
  if(state.exclTris[group] && state.exclTris[group].size){
    return Array.from(state.exclTris[group]).map(t => ({sub:t, cls:"u-red"}));
  }
  return [];
}

function inferredSingleTrigram(group){
  const n = getN();
  const p = current();
  const w = norm(group === 'w1' ? p.word1 : p.word2);
  if(!w) return null;

  const found = [];
  for(let s=0; s<=n-3; s++){
    const a = cellChar(s), b = cellChar(s+1), c = cellChar(s+2);
    if(!a || !b || !c) continue;
    const tri = (a+b+c).toLowerCase();
    if(w.includes(tri)) found.push(tri);
  }

  const uniq = [];
  const seen = new Set();
  for(const t of found){
    if(seen.has(t)) continue;
    seen.add(t);
    uniq.push(t);
  }

  return (uniq.length === 1) ? uniq[0] : null;
}
function triForClue(group){
  const pl = state.placed[group];
  if(pl && pl.tri) return pl.tri;
  return inferredSingleTrigram(group);
}

/* =======================
   Placing / cycling
   ======================= */
function placeTrigram(group, tri){
  const f = flags();
  if(!f.allowClueTapPlace && !f.allowHintTapPlace) return false;
  if(state.finished) return false;

  const before = snapshotGridChars();
  clearTransientOnAnyChange();

  const n = getN();
  const t = norm(tri);
  if(!t || t.length !== 3) return false;

  const otherGroup = group === 'w1' ? 'w2' : 'w1';
  const other = state.placed[otherGroup];

  let start = (state.placed[group] ? state.placed[group].start : null);
  const focus = clamp(state.focusIdx ?? 0, 0, n-1);
  const prefStart = clamp(focus, 0, startMax());

  function tryStartsInOrder(){
    const order = [];
    order.push(prefStart);
    for(let d=1; d<=startMax(); d++){
      if(prefStart-d >= 0) order.push(prefStart-d);
      if(prefStart+d <= startMax()) order.push(prefStart+d);
    }
    return order;
  }

  if(start == null){
    start = null;
    for(const s of tryStartsInOrder()){
      if(other){
        const ol = overlapCount(s, other.start);
        if(ol > 1) continue;
        if(ol === 1 && !overlapIsValid(s, t, other.start, other.tri)) continue;
      }
      start = s; break;
    }
    if(start == null){
      setTransientMsg("can’t place", 1800);
      return false;
    }
  }else{
    if(other){
      const ol = overlapCount(start, other.start);
      const ok = (ol <= 1) && (ol !== 1 || overlapIsValid(start, t, other.start, other.tri));
      if(!ok){
        start = null;
        for(const s of tryStartsInOrder()){
          const ol2 = overlapCount(s, other.start);
          if(ol2 > 1) continue;
          if(ol2 === 1 && !overlapIsValid(s, t, other.start, other.tri)) continue;
          start = s; break;
        }
        if(start == null){
          setTransientMsg("can’t place", 1800);
          return false;
        }
      }
    }
  }

  state.placed[group] = {start, tri:t};
  removeSinglesInCells(trigramCells(start));
  setMiniHighlightToTri(group, t);

  addEffortFromGridChange(before, { countDeletes:true, base:0.5 });
  return true;
}

function cyclePlacedTrigram(group, opts = {}){
  if(!flags().allowClueTapCycle) return;
  if(state.finished) return;

  const pl = state.placed[group];
  if(!pl) return;

  const p = current();
  const w = norm(group === 'w1' ? p.word1 : p.word2);
  const maxStart = Math.max(0, w.length - 3);
  if(maxStart === 0) return;

  const countCycle = (opts.countCycle !== false);
  if(countCycle){
    state.cycleCount = (state.cycleCount || 0) + 1;
    if(state.hintsUsed.w1) state.postHint1Cycles = (state.postHint1Cycles || 0) + 1;
    else state.preHint1Cycles = (state.preHint1Cycles || 0) + 1;
  }

  const curTri = norm(pl.tri);
  const curPos = w.indexOf(curTri);
  if(curPos >= 0){
    if(group === 'w1') state.sel1 = clamp(curPos, 0, maxStart);
    else state.sel2 = clamp(curPos, 0, maxStart);
  }else{
    if(group === 'w1') state.sel1 = 0;
    else state.sel2 = 0;
  }

  let s = (group === 'w1' ? state.sel1 : state.sel2);
  if(s == null) s = 0;
  s = (s + 1) % (maxStart + 1);
  if(group === 'w1') state.sel1 = s; else state.sel2 = s;

  const tri = w.slice(s, s+3);
  placeTrigram(group, tri);
}

function firstTrigramOfWord(group){
  const p = current();
  const w = norm(group === 'w1' ? p.word1 : p.word2);
  if(w.length < 3) return null;
  return w.slice(0, 3);
}

/* =======================
   Hint track UI
   ======================= */
function bindTapReliable(node, fn){
  if(!node) return;
  let last = 0;

  const fire = (e)=>{
    const now = performance.now();
    if(now - last < 260) return;
    last = now;
    try{ fn(e); }catch(err){ console.error(err); }
  };

  node.addEventListener('pointerup', (e)=>{
    if(e.pointerType === 'mouse' && e.button !== 0) return;
    e.preventDefault();
    e.stopPropagation();
    fire(e);
  }, {passive:false});

  node.addEventListener('click', (e)=>{
    e.preventDefault();
    e.stopPropagation();
    fire(e);
  }, {passive:false});

  node.addEventListener('touchend', (e)=>{
    e.preventDefault();
    e.stopPropagation();
    fire(e);
  }, {passive:false});

  node.addEventListener('keydown', (e)=>{
    if(e.key === 'Enter' || e.key === ' '){
      e.preventDefault();
      fire(e);
    }
  });
}

function makeTrigramBlock(tri, cls, labelText, onTap, id){
  const block = document.createElement('div');
  block.className = "trackBlock";

  const box = document.createElement('div');
  box.className = "letters clickable";
  box.setAttribute("aria-label", labelText);
  if(id) box.id = id;

  if(typeof onTap === "function"){
    bindTapReliable(box, onTap);
  }

  for(let i=0;i<tri.length;i++){
    const d = document.createElement('div');
    d.className = "letter " + cls;
    d.textContent = tri[i];
    box.appendChild(d);
  }
  block.appendChild(box);
  return block;
}

function renderHintTrack(){
  const p = current();

  el.trackW1.innerHTML = "";
  el.trackW2.innerHTML = "";
  el.trackExtras.innerHTML = "";

  el.trackW1.style.display = "none";
  el.trackW2.style.display = "none";
  el.trackExtras.style.display = "none";

  if(state.hintsUsed.w1){
    el.trackW1.appendChild(
      makeTrigramBlock(norm(p.tri1), "sel-w1", "word 1 trigram", ()=>{
        if(state.finished || state.modalOpen) return;
        if(!state.assist) return;
        placeTrigram('w1', norm(p.tri1));
        renderSmart();
      }, "trackBox-w1")
    );
    const bx1 = el.trackW1.querySelector('#trackBox-w1');
    if(bx1) bx1.classList.toggle('is-in-grid', gridHasExactTrigram(p.tri1));
    el.trackW1.style.display = "";

    if(state.pendingFly === 'w1'){
      const bx = el.trackW1.querySelector('#trackBox-w1');
      if(bx) bx.style.opacity = "0";
    }
  }

  if(state.hintsUsed.w2){
    el.trackW2.appendChild(
      makeTrigramBlock(norm(p.tri2), "sel-w2", "word 2 trigram", ()=>{
        if(state.finished || state.modalOpen) return;
        if(!state.assist) return;
        placeTrigram('w2', norm(p.tri2));
        renderSmart();
      }, "trackBox-w2")
    );
    const bx2 = el.trackW2.querySelector('#trackBox-w2');
    if(bx2) bx2.classList.toggle('is-in-grid', gridHasExactTrigram(p.tri2));
    el.trackW2.style.display = "";

    if(state.pendingFly === 'w2'){
      const bx = el.trackW2.querySelector('#trackBox-w2');
      if(bx) bx.style.opacity = "0";
    }
  }

  if(state.hintsUsed.extras){
    if(state.bank.length === 0) rebuildBank();

    const block = document.createElement('div');
    block.className = "trackBlock";

    const row = document.createElement('div');
    row.className = "extrasRow";
    row.id = "trackBox-extras";

    for(const tile of state.bank){
      const box = document.createElement('div');
      box.className = "letters clickable";

      const d = document.createElement('div');
      d.className = "letter extra";
      d.textContent = tile.ch;

      if(state.pendingFly === 'extras') d.style.opacity = "0";

      bindTapReliable(d, ()=>{
        if(state.finished) return;
        if(state.modalOpen) return;
        clearTransientOnAnyChange();
        if(!state.assist) return;

        const n = getN();
        for(let i=0;i<n;i++){
          if(state.placed.w1 && i>=state.placed.w1.start && i<state.placed.w1.start+3) continue;
          if(state.placed.w2 && i>=state.placed.w2.start && i<state.placed.w2.start+3) continue;
          if(state.singles.find(s=>s.idx===i)) continue;

          addEffort(1);
          state.singles.push({id: uid(), ch: tile.ch, idx: i});
          state.focusIdx = clamp(i+1,0,n-1);
          renderSmart();
          return;
        }
        setTransientMsg("No blank spot", 2000);
      });

      box.appendChild(d);
      row.appendChild(box);
    }

    block.appendChild(row);
    el.trackExtras.appendChild(block);
    el.trackExtras.style.display = "";
  }

  updateExtrasHintFade();
}

/* =======================
   Clue tap behavior (merged enable + actions; capture)
   ======================= */
function onClueWordActivate(group){
  if(state.finished) return;
  if(state.modalOpen) return;
  if(group !== 'w1' && group !== 'w2') return;

  clearTransientOnAnyChange();

  if(state.placed[group]){
    cyclePlacedTrigram(group, { countCycle: !state.hintsUsed[group] });
  }else{
    let tri = null;
    if(group === 'w1' && state.hintsUsed.w1) tri = norm(current().tri1);
    if(group === 'w2' && state.hintsUsed.w2) tri = norm(current().tri2);
    if(!tri) tri = firstTrigramOfWord(group);
    if(tri) placeTrigram(group, tri);
  }

  renderSmart();
}

(function bindClueTap(){
  if(!el.clue) return;

  let lastActionAt = 0;
  let handledPointerAt = 0;

  const handler = (e, isClick=false)=>{
    if(state.finished || state.modalOpen) return;

    if(!isClick) handledPointerAt = Date.now();
    e.preventDefault();
    e.stopPropagation();

    const w = e.target && e.target.closest ? e.target.closest('.clueWord') : null;
    const group = w ? w.dataset.group : null;

    if(!state.assist){
      // Enable enhanced on first clue interaction
      if(group && !state.placed[group]){
        setEnhanced(true, false, 'user'); // enable but avoid double render here
        lastActionAt = Date.now();
        onClueWordActivate(group);
        return;
      }
      setEnhanced(true, true, 'user');
      lastActionAt = 0;
      if(!state.useCustomKB) requestAnimationFrame(()=> focusCell(state.focusIdx ?? 0));
      return;
    }

    if(!w) return;

    const now = Date.now();
    if(now - lastActionAt < 220) return;
    lastActionAt = now;

    onClueWordActivate(group);
  };

  el.clue.addEventListener('pointerdown', (e)=> handler(e,false), { passive:false, capture:true });
  el.clue.addEventListener('click', (e)=>{
    if(Date.now() - handledPointerAt < 650){ e.preventDefault(); return; }
    handler(e,true);
  }, { passive:false, capture:true });
})();

/* =======================
   Keyboard (custom)
   ======================= */
function shouldUseCustomKB(){
  const coarse = window.matchMedia && window.matchMedia('(pointer:coarse)').matches;
  const small  = window.matchMedia && window.matchMedia('(max-width: 920px)').matches;
  return !!(coarse && small);
}
function setCustomKBEnabled(on){
  state.useCustomKB = !!on;
  document.documentElement.classList.toggle('has-kb', state.useCustomKB);
  buildKeyboard();
  requestAnimationFrame(()=>{
    updateKeyboardHeightVar();
    updateBtnRowHeightVar();
    updateHintTrackPlacement();
  });
}
function updateKeyboardHeightVar(){
  if(!state.useCustomKB) return;
  const rect = el.kbHost.getBoundingClientRect();
  if(rect && rect.height){
    document.documentElement.style.setProperty('--kb-h', `${Math.ceil(rect.height)}px`);
  }
}
function pressKeyAction(kind, val){
  if(state.finished) return;
  if(state.modalOpen) return;

  if(kind === 'letter'){
    typeLetterIntoGrid(val);
  }else if(kind === 'delete'){
    clearTransientOnAnyChange();
    backspaceAtIndex(state.focusIdx ?? 0);
    renderSmart();
  }else if(kind === 'reset'){
    resetMainGridOnly();
  }
}
function makeKey(label, aria, cls, kind, val){
  const b = document.createElement('button');
  b.type = "button";
  b.className = `kbKey ${cls||""}`.trim();
  b.setAttribute('aria-label', aria || label);

  if(kind === 'letter'){
    b.textContent = label;
  }else if(kind === 'reset'){
    b.textContent = "RESET";
  }else if(kind === 'delete'){
    const img = document.createElement('img');
    img.src = 'delete-.svg';
    img.alt = '';
    img.className = 'kbIcon';
    img.setAttribute('aria-hidden', 'true');
    img.draggable = false;
    b.appendChild(img);
  }

  b.addEventListener('pointerdown', (e)=>{
    e.preventDefault();
    e.stopPropagation();
    if(b.classList.contains('is-disabled')) return;
    pressKeyAction(kind, val);
  }, {passive:false});

  return b;
}
function buildKeyboard(){
  el.kbHost.innerHTML = "";
  if(!state.useCustomKB) return;

  const kb = document.createElement('div');
  kb.className = "kb";

  ["QWERTYUIOP","ASDFGHJKL"].forEach((row)=>{
    const r = document.createElement('div');
    r.className = "kbRow";
    for(const ch of row){
      r.appendChild(makeKey(ch, `Letter ${ch}`, "", "letter", ch.toLowerCase()));
    }
    kb.appendChild(r);
  });

  const r3 = document.createElement('div');
  r3.className = "kbRow";
  r3.appendChild(makeKey("RESET", "Reset", "wide reset", "reset", null));
  for(const ch of "ZXCVBNM"){
    r3.appendChild(makeKey(ch, `Letter ${ch}`, "", "letter", ch.toLowerCase()));
  }
  r3.appendChild(makeKey("DEL", "Delete", "wide delete", "delete", null));
  kb.appendChild(r3);

  el.kbHost.appendChild(kb);

  // tap-near-a-key helper (mobile)
  el.kbHost.onpointerdown = (e)=>{
    if(!state.useCustomKB || state.finished || state.modalOpen) return;
    if(e.target && e.target.closest && e.target.closest('.kbKey')) return;

    const keys = Array.from(el.kbHost.querySelectorAll('.kbKey'));
    if(!keys.length) return;

    let best = null;
    for(const k of keys){
      const r = k.getBoundingClientRect();
      const cx = (r.left + r.right)/2;
      const cy = (r.top + r.bottom)/2;
      const dx = e.clientX - cx;
      const dy = e.clientY - cy;
      const d2 = dx*dx + dy*dy;
      if(best == null || d2 < best.d2) best = {k, d2};
    }

    const THRESH = 34;
    if(best && best.d2 <= THRESH*THRESH){
      e.preventDefault();
      best.k.dispatchEvent(new PointerEvent('pointerdown', {bubbles:true, cancelable:true, clientX:e.clientX, clientY:e.clientY}));
    }
  };

  requestAnimationFrame(()=> updateKeyboardHeightVar());
}

/* =======================
   Hint track placement (TOP vs BOTTOM)
   ======================= */
const KB_FORCE_TOP_RATIO = 0.8;
const HINT_PAD = 10;
let _hintTrackMode = null;

function updateBtnRowHeightVar(){
  const r = el.btnRow?.getBoundingClientRect?.();
  if(r && r.height){
    document.documentElement.style.setProperty('--btn-row-h', `${Math.ceil(r.height)}px`);
  }
}
function applyHintTrackMode(mode){
  if(_hintTrackMode === mode) return;
  _hintTrackMode = mode;

  if(mode === 'top'){
    if(el.clue) el.clue.insertAdjacentElement('afterend', el.hintTrack);
    el.hintTrack.classList.add('hintTrackTop');
    if(el.clueWrap) el.clueWrap.classList.add('hasTopTrack');
  }else{
    if(el.hintDockBottom) el.hintDockBottom.appendChild(el.hintTrack);
    el.hintTrack.classList.remove('hintTrackTop');
    if(el.clueWrap) el.clueWrap.classList.remove('hasTopTrack');
  }
}
/* =======================
   Hint track placement (top vs bottom)
   ======================= */

function moveHintTrackTop(){
  if(!el.hintTrack || !el.clueWrap) return;
  if(el.hintTrack.parentElement === el.clueWrap) return;

  el.clueWrap.appendChild(el.hintTrack);
  el.clueWrap.classList.add('hasTopTrack');
  el.hintTrack.classList.add('hintTrackTop');
}

function moveHintTrackBottom(){
  if(!el.hintTrack || !el.hintDockBottom) return;
  if(el.hintTrack.parentElement === el.hintDockBottom) return;

  el.hintDockBottom.appendChild(el.hintTrack);
  el.clueWrap.classList.remove('hasTopTrack');
  el.hintTrack.classList.remove('hintTrackTop');
}

  
function updateHintTrackPlacement(){
  const track      = el.hintTrack;
  const topHost    = el.clueWrap;
  const bottomHost = el.hintDockBottom;
  const gridDock   = el.gridDock;
  const btnRow     = el.btnRow;

  if(!track || !topHost || !bottomHost || !gridDock || !btnRow) return;

  const root  = document.documentElement;
  const hasKB = root.classList.contains('has-kb');

  // Measure current layout
  const gridRect  = gridDock.getBoundingClientRect();
  const btnRect   = btnRow.getBoundingClientRect();
  const trackRect = track.getBoundingClientRect();

  // If we can’t measure properly, fall back to bottom
  if(!gridRect || !btnRect || !trackRect){
    if(track.parentNode !== bottomHost) bottomHost.appendChild(track);
    topHost.classList.remove('hasTopTrack');
    track.classList.remove('hintTrackTop');
    return;
  }


  const available = btnRect.top - gridRect.bottom;


  const MIN_GAP = 12; // breathing room above the bottom row
  const needTop = hasKB && (available < (trackRect.height + MIN_GAP));

  const currentlyTop = (track.parentNode === topHost);

  if(needTop){
    // Move to TOP (under clue)
    if(!currentlyTop){
      topHost.appendChild(track);
    }
    topHost.classList.add('hasTopTrack');
    track.classList.add('hintTrackTop');
  }else{
    // Keep / move to BOTTOM dock
    if(currentlyTop || track.parentNode !== bottomHost){
      bottomHost.appendChild(track);
    }
    topHost.classList.remove('hasTopTrack');
    track.classList.remove('hintTrackTop');
  }
}


window.addEventListener('resize', ()=> requestAnimationFrame(updateHintTrackPlacement), {passive:true});
if(window.visualViewport){
  window.visualViewport.addEventListener('resize', ()=> requestAnimationFrame(updateHintTrackPlacement), {passive:true});
}

/* =======================
   RESET main grid only (keyboard RESET)
   ======================= */
function resetMainGridOnly(){
  if(state.modalOpen) return;
  if(state.finished) return;

  clearTransientOnAnyChange();
  abortDrag();

  state.placed = { w1:null, w2:null };
  state.singles = [];
  state.focusIdx = 0;

  renderSmart();

  if(!state.useCustomKB){
    requestAnimationFrame(()=> focusCell(0));
  }
}

/* =======================
   Render grid
   ======================= */
function renderGrid(stealFocus=true){
  const n = getN();
  const f = flags();
  const revealed = state.finished;

  if(!revealed && f.allowAutoPromote){
    for(let k=0;k<2;k++){
      if(!autoPromoteTypedTrigrams()) break;
    }
  }

  computeTwoLetterOverlapInvalid();
  computeMax3Invalid();
  computeTwoTrigramsInvalid();
  computeHintExcludedTrigrams();

  const overlapSet = (!revealed && f.showGridColors) ? computeOverlapIdxSet() : new Set();

  el.grid.style.setProperty('--n', String(n));
  el.grid.innerHTML = "";

  for(let i=0;i<n;i++){
    const cell = document.createElement('div');
    cell.className = "cell";
    cell.dataset.idx = String(i);

    if(!revealed && i === clamp(state.focusIdx ?? 0, 0, n-1)){
      cell.classList.add('active');
    }

    const tri = trigramAtIndex(i);

    if(!revealed && f.showGridColors && tri){
      if(overlapSet.has(i)) cell.classList.add('bg-ol');
      else cell.classList.add(tri.group==='w1' ? 'bg-w1' : 'bg-w2');
    }
    if(!revealed && f.showBadCellColor && (state.ol2Set.has(i) || state.badSet.has(i) || state.twoSet.has(i) || state.exclSet.has(i))){
      cell.classList.add('bg-bad');
    }
    if(!revealed && f.allowDragTrigrams && tri){
      cell.classList.add('grabbable');
    }

    const input = document.createElement('input');
    input.type = "text";
    input.inputMode = "none";
    input.autocapitalize = "none";
    input.autocomplete = "off";
    input.autocorrect = "off";
    input.spellcheck = false;
    input.maxLength = 1;
    input.dataset.idx = String(i);
    input.value = cellChar(i);
    input.name = "x-"+i;
    input.enterKeyHint = "done";

    const ro = (!!tri && f.allowAutoPromote) || revealed || state.useCustomKB;
    input.readOnly = ro;
    input.tabIndex = state.useCustomKB ? -1 : 0;

    input.addEventListener('focus', ()=>{ state.focusIdx = i; });

    input.addEventListener('keydown', (e)=>{
      if(revealed) return;
      if(state.modalOpen){ e.preventDefault(); return; }

      if(e.key === " " || e.code === "Space" || e.key === "Spacebar"){
        e.preventDefault(); e.stopPropagation();
        clearTransientOnAnyChange();
        focusCell(i + 1);
        renderSmart();
        return;
      }
      if(e.key === "ArrowLeft"){ e.preventDefault(); e.stopPropagation(); clearTransientOnAnyChange(); focusCell(i - 1); renderSmart(); return; }
      if(e.key === "ArrowRight"){ e.preventDefault(); e.stopPropagation(); clearTransientOnAnyChange(); focusCell(i + 1); renderSmart(); return; }

      if(e.key && e.key.length === 1 && isAlpha(e.key) && !input.readOnly){
        e.preventDefault();
        clearTransientOnAnyChange();
        typeLetterAtIndex(i, e.key);
        renderSmart();
        return;
      }

      if(e.key === "Backspace" || e.key === "Delete"){
        e.preventDefault();
        e.stopPropagation();
        clearTransientOnAnyChange();
        backspaceAtIndex(i);
        renderSmart();
        return;
      }

      if(e.key === "Enter"){
        e.preventDefault();
        onCheck();
        return;
      }
    });

    if(!input.readOnly){
      input.addEventListener('input', ()=>{
        if(state.modalOpen) return;
        clearTransientOnAnyChange();
        const v = input.value || "";
        const ch = v.slice(-1);
        if(!ch){ renderSmart(); return; }
        if(!isAlpha(ch)){ input.value = cellChar(i); renderSmart(); return; }
        typeLetterAtIndex(i, ch);
        renderSmart();
      });
    }

    cell.addEventListener('pointerdown', (e)=>{
      if(revealed) return;
      if(state.modalOpen) return;

      state.focusIdx = i;

      if(!state.useCustomKB){
        requestAnimationFrame(()=> focusCell(i));
      }

      if(f.allowDragTrigrams){
        const t = trigramAtIndex(i);
        if(t){
          clearTransientOnAnyChange();
          beginDragWithThreshold(e, (ev)=>startDragTrigram(ev, t.group, t.tri, i, t.start));
        }
      }

      renderSmart();
    });

    cell.appendChild(input);
    el.grid.appendChild(cell);
  }

  if(stealFocus && !revealed && !state.useCustomKB && !state.modalOpen){
    requestAnimationFrame(()=> focusCell(state.focusIdx ?? 0));
  }
}

/* =======================
   Hints: sequential button
   ======================= */
function nextHintStage(){
  if(!state.hintsUsed.w1) return 1;
  if(!state.hintsUsed.w2) return 2;
  if(!state.hintsUsed.extras) return 3;
  return 4;
}
function updateHintButtonLabel(){
  if(state.finished){
    el.hintsBtn.disabled = true;
    return;
  }
  const st = nextHintStage();
  el.hintsBtn.textContent = (st === 1) ? "hint 1" : (st === 2) ? "hint 2" : (st === 3) ? "hint 3" : "give up";
}

function applyHint(id){
  if(state.finished) return;

  if(id === HINT_IDS.w1){
    if(state.hintsUsed.w1) return;

    skillStartNewSegmentAfterHint();

    state.hintsUsed.w1 = true;
    state.hintCount += 1;

    scheduleHintFly('w1');
    renderSmart();
    return;
  }

  if(id === HINT_IDS.w2){
    if(state.hintsUsed.w2) return;
    if(!state.hintsUsed.w1) return;

    skillStartNewSegmentAfterHint();

    state.hintsUsed.w2 = true;
    state.hintCount += 1;

    scheduleHintFly('w2');
    renderSmart();
    return;
  }

  if(id === HINT_IDS.extras){
    if(state.hintsUsed.extras) return;
    if(!extrasUnlocked()) return;

    skillStartNewSegmentAfterHint();

    state.hintsUsed.extras = true;
    state.hintCount += 1;
    if(state.bank.length === 0) rebuildBank();

    scheduleHintFly('extras');
    renderSmart();
    return;
  }
}

/* =======================
   Buttons / nav
   ======================= */
function bindFastTap(btn, fn){
  if(!btn) return;
  let last = 0;
  const run = (e)=>{
    const now = Date.now();
    if(e){
      e.preventDefault();
      e.stopPropagation();
    }
    if(now - last < 250) return;
    last = now;
    fn();
  };

  btn.addEventListener('pointerdown', run, {passive:false});
  btn.addEventListener('click', (e)=>{
    if(Date.now() - last < 400){ e.preventDefault(); return; }
    run(e);
  });
}

bindFastTap(el.hintsBtn, ()=>{
  if(state.finished) return;
  if(state.modalOpen) return;

  const st = nextHintStage();
  if(st === 1) applyHint(HINT_IDS.w1);
  else if(st === 2) applyHint(HINT_IDS.w2);
  else if(st === 3) applyHint(HINT_IDS.extras);
  else revealAnswerGiveUp();
});

bindFastTap(el.checkBtn, onCheck);

el.prevBtn.addEventListener('click', (e)=>{
  e.preventDefault();
  clearTransientOnAnyChange();
  closeModal();

  state.i = (state.i - 1 + PUZZLES.length) % PUZZLES.length;
  resetAllForPuzzle();

 
  if (!applyStoredResultToCurrentPuzzle()) {
    renderSmart();
  }
});

el.nextBtn.addEventListener('click', (e)=>{
  e.preventDefault();
  clearTransientOnAnyChange();
  closeModal();

  state.i = (state.i + 1) % PUZZLES.length;
  resetAllForPuzzle();


  if (!applyStoredResultToCurrentPuzzle()) {
    renderSmart();
  }
});

  // Stats button wiring
if(el.statsBtn){
  el.statsBtn.addEventListener('click', (e)=>{
    e.preventDefault();
    openStats();
  });
}
if(el.statsClose){
  el.statsClose.addEventListener('click', (e)=>{
    e.preventDefault();
    closeStats();
  });
}
if(el.statsOverlay){
  el.statsOverlay.addEventListener('click', (e)=>{
    if(e.target === el.statsOverlay){
      e.preventDefault();
      closeStats();
    }
  }, { passive:false });
}


document.addEventListener('keydown', (e)=>{
  if(state.finished) return;
  if(state.modalOpen) return;

  const target = e.target;
  const inGrid = target && target.closest && target.closest('#gridWrap');

  if(!inGrid && e.key && e.key.length === 1 && isAlpha(e.key)){
    const isOtherTyping = target && target.tagName === "INPUT";
    if(!isOtherTyping){
      e.preventDefault();
      typeLetterIntoGrid(e.key);
      return;
    }
  }

  if(e.key === "Backspace" || e.key === "Delete"){
    if(!inGrid || state.useCustomKB){
      e.preventDefault();
      clearTransientOnAnyChange();
      if(deleteFromEnd()) renderSmart();
      return;
    }
  }
});

/* =======================
   Render
   ======================= */
function render(stealFocus=true){
  const p = current();
  ensurePuzzleDerived(p);

  const n = getN();
  el.count.textContent = `${state.i+1}/${PUZZLES.length}`;

  el.wrap.classList.toggle('solved', state.finished);
  el.wrap.classList.toggle('gaveup', state.gaveUp);

  renderGrid(stealFocus);

  const [t1, t2] = splitClueTwoWords(p.clue);

  const err1 = errorItemsForGroup('w1');
  const err2 = errorItemsForGroup('w2');

  let a = escapeHtml(t1);
  let b = escapeHtml(t2);

  if(err1.length) a = underlineBySubstrings(t1, err1);
  else{
    const tri1 = triForClue('w1');
    if(tri1) a = underlineBySubstrings(t1, [{sub:tri1, cls:"u-w1"}]);
  }

  if(err2.length) b = underlineBySubstrings(t2, err2);
  else{
    const tri2 = triForClue('w2');
    if(tri2) b = underlineBySubstrings(t2, [{sub:tri2, cls:"u-w2"}]);
  }

  el.clue.innerHTML =
    `<span class="clueWord" data-group="w1">${a}</span> ` +
    `<span class="clueWord" data-group="w2">${b}</span>` +
    `<span class="len">(${n})</span>`;

  renderHintTrack();

  el.checkBtn.classList.toggle('ready', canEnableCheckNow());
  el.checkBtn.disabled = state.finished;

  el.hintsBtn.disabled = state.finished;
  updateHintButtonLabel();

  updateStatusMessages();
}

/* =======================
   Resets + init
   ======================= */
function resetAllForPuzzle(){
  state.finished = false;
  state.gaveUp = false;
  el.wrap.classList.remove('solved','gaveup');

  resetEnhancedForNewPuzzle();

  const badgeVal = document.getElementById('skillBadgeValue');
  if(badgeVal) badgeVal.textContent = "—";

  state.cycleCount = 0;
  state.wrongCheckCount = 0;
  state.preHint1Cycles = 0;
  state.postHint1Cycles = 0;
  state.effortUnits = 0;

  state.hintCount = 0;
  state.hintsUsed = { w1:false, w2:false, extras:false };

  state.bank = [];
  state.pendingFly = null;
  state.flyAttempts = 0;

  state.placed = {w1:null, w2:null};
  state.singles = [];
  state.focusIdx = 0;
  state.sel1 = null;
  state.sel2 = null;

  setMsg("");
  state.overlapMsgOn = false;
  state.lockMsg = false;

  abortDrag();
  skillResetForPuzzle();
}

window.addEventListener('resize', ()=>{
  const next = shouldUseCustomKB();
  if(next !== state.useCustomKB) setCustomKBEnabled(next);
  updateKeyboardHeightVar();
});

/* init */
window.addEventListener('resize', ()=>{
  const next = shouldUseCustomKB();
  if(next !== state.useCustomKB) setCustomKBEnabled(next);
  updateKeyboardHeightVar();
});

/* init */
function init(){
  // 7) Respect ?reset in the URL (clears stored stats/results)
  checkResetParam();

  // 8) Start on the first unplayed puzzle (falls back to last if all done)
  state.i = firstUnplayedPuzzleIndex();

  // Default mode pill text (will be overridden if we rehydrate a solved puzzle)
  updateModePill();

  // Keyboard mode (mobile vs desktop)
  setCustomKBEnabled(shouldUseCustomKB());

  // Fresh state for this puzzle
  resetAllForPuzzle();

  // 9) If this puzzle already has a saved result, restore it;
  // otherwise render a fresh unsolved grid.
  if (!applyStoredResultToCurrentPuzzle()) {
    renderSmart();
  }
}

// Run init immediately
init();

</script>

</body>
</html>
